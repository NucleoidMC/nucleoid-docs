{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome!","text":"<p>Here you can find documentation about Nucleoid's libraries and other tools. Have a look in the navigation bar to find what you are looking for.</p> <p>If you want to get started making a minigame, you probably want to look at Plasmid. If you want to contribute translations, see our Weblate. You can also come and chat to us on Discord in the <code>#minigame-dev</code> channel!</p>"},{"location":"backend/","title":"About","text":"<p>Nucleoid uses a backend service written in rust as a central point for storing and handling data. It is currently used for the following things:</p> <ul> <li>HTTP API used to query information about the server and players.</li> <li>Discord bot and relays to link ingame chat to Discord channels.</li> <li>Statistics storage in a ClickHouse database</li> <li>Recording performance metrics from the Minecraft servers into a postgresql database, for display on Grafana.</li> </ul>"},{"location":"backend/http-api/","title":"HTTP API","text":"<p>Nucleoid's backend service provides a few API endpoints for querying information about the server and players.</p> <p>The official backend API is available on https://api.nucleoid.xyz/</p>"},{"location":"backend/http-api/#general-information","title":"General information","text":""},{"location":"backend/http-api/#data-types","title":"Data types","text":"<p>All dates/times returned by the API are in RFC 3339 format unless specified otherwise.</p>"},{"location":"backend/http-api/#limits","title":"Limits","text":"<p>By default, the backend has a maximum query size of 50, however this can and may be changed in future. This applies to all routes that take a <code>limit</code> query parameter.</p> <p>There is currently also no rate-limiting on the API, however this may change in future if it causes issues.</p>"},{"location":"backend/http-api/#status","title":"Status","text":""},{"location":"backend/http-api/#server-status","title":"Server status","text":"<p>Example</p> <pre><code>GET https://api.nucleoid.xyz/status/play\n\n{\n    \"game_version\": \"1.16.4\",\n    \"server_ip\": \"nucleoid.xyz\",\n    \"games\": [\n        {\n            \"name\": \"Bedwars\",\n            \"type\": \"bedwars:bedwars\",\n            \"player_count\": 1\n        }\n    ],\n    \"players\": [\n        {\n            \"name\": \"Tom_The_Geek\",\n            \"id\": \"07e92b46-8386-4067-8f72-8ab96e606fb7\"\n        }\n    ]\n}\n</code></pre> <p>This endpoint allows you to query the status of any of the Nucleoid servers. Currently the following servers are available to query:</p> <ul> <li><code>play</code>: The main server on hosted on <code>nucleoid.xyz</code> and <code>play.nucleoid.xyz</code></li> <li><code>build</code>: The whitelisted server used for map building, hosted on <code>build.nucleoid.xyz</code></li> </ul> Field Description <code>game_version</code> The version of Minecraft the server is running <code>server_ip</code> The public IP of the server, optional <code>games</code> A list of all open minigames on the server <code>players</code> A list of all players on the server"},{"location":"backend/http-api/#statistics","title":"Statistics","text":""},{"location":"backend/http-api/#get-recent-games","title":"Get recent games","text":"<p>Example</p> <pre><code>GET https://api.nucleoid.xyz/games/recent?limit=10\n\n[\n    {\n        \"id\":\"f0087cb4-dee2-4b99-8158-d20cd72b343d\",\n        \"namespace\": \"bedwars\",\n        \"players\": [\n            \"5ad3ab57-b556-4635-9ba9-9a9a0568965a\"\n        ],\n        \"server\": \"play\",\n        \"date_played\": \"2021-10-30T16:24:47Z\"\n    }\n]\n</code></pre> <p>Queries a list of recently played games on the server. The limit argument is required and specifies the maximum number of games returned.</p>"},{"location":"backend/http-api/#recent-game-object","title":"Recent game object","text":"Field Description <code>id</code> The ID of the game, can be used to query with the Get stats for game endpoint <code>namespace</code> Usually the ID of the game that was played <code>players</code> A list of the player IDs of the players in the game <code>server</code> ID of the server the game was played on (see Server status) <code>date_played</code> Timestamp of when the game was played"},{"location":"backend/http-api/#get-recent-games-player","title":"Get recent games (player)","text":"<p>Example</p> <pre><code>GET https://api.nucleoid.xyz/games/recent?limit=10&amp;player=f0087cb4-dee2-4b99-8158-d20cd72b343d\n\n[\n    {\n        \"id\":\"f0087cb4-dee2-4b99-8158-d20cd72b343d\",\n        \"namespace\": \"bedwars\",\n        \"players\": [\n            \"5ad3ab57-b556-4635-9ba9-9a9a0568965a\"\n        ],\n        \"server\": \"play\",\n        \"date_played\": \"2021-10-30T16:24:47Z\"\n    }\n]\n</code></pre> <p>Queries a list of recently played games by a particular player on the server.</p> <p>The limit argument is required and specifies the maximum number of games returned.</p> <p>The returned object is the same format as Get recent games, and is documented at Recent game object</p>"},{"location":"backend/http-api/#get-all-player-stats","title":"Get all player stats","text":"<p>Example</p> <pre><code>GET https://api.nucleoid.xyz/stats/player/07e92b46-8386-4067-8f72-8ab96e606fb7\n\n{\n    \"bedwars\": {\n        \"damage_dealt\": 1238.8,\n        \"final_kills\": 56.0,\n        \"kills\": 84.0,\n        \"blocks_placed\": 532.0,\n        \"beds_destroyed\": 21.0\n    }\n}\n</code></pre> <p>Allows for querying all the statistics of a player.</p> <p>Note</p> <p>The response is relatively unstructured, as players may have different combinations of games they have collected statistics for.</p> <p>The best way to describe the response of this endpoint is by describing the data format on the backend. The data returned is described in rust as <pre><code>type PlayerStatisticsResponse = HashMap&lt;String, HashMap&lt;String, f64&gt;&gt;;\n</code></pre> Rust's <code>HashMap</code>s are similar to dictionaries in other languages or objects in JavaScript.</p>"},{"location":"backend/http-api/#get-player-stats-for-a-game","title":"Get player stats for a game","text":"<p>Example</p> <pre><code>GET https://api.nucleoid.xyz/stats/player/07e92b46-8386-4067-8f72-8ab96e606fb7/bedwars\n\n{\n    \"bedwars\": {\n        \"damage_dealt\": 1238.8,\n        \"final_kills\": 56.0,\n        \"kills\": 84.0,\n        \"blocks_placed\": 532.0,\n        \"beds_destroyed\": 21.0\n    }\n}\n</code></pre> <p>Allows for filtering the returned statistics by a particular game/namespace. It will return a response in the same format as Get all player stats, just without stats for minigames other than the specified one.</p>"},{"location":"backend/http-api/#get-stats-for-game","title":"Get stats for game","text":"<p>Example</p> <pre><code>GET https://api.nucleoid.xyz/stats/game/bda420f0-b480-4f8b-bcc5-7c6c63d51643\n\n{\n    \"07e92b46-8386-4067-8f72-8ab96e606fb7\": {\n        \"bedwars\": {\n            \"final_kills\": 8,\n            \"blocks_placed\": 76,\n            \"beds_destroyed\": 3,\n            \"kills\": 12,\n            \"damage_dealt\": 154.85\n        }\n    },\n    \"00000000-0000-0000-0000-000000000000\": {\n        \"bedwars\": {\n            \"teams\": 4\n        }\n    }\n}\n</code></pre> <p>Allows for querying the statistics after a particular game has been played.</p> <p>Note</p> <p>The <code>00000000-0000-0000-0000-000000000000</code> UUID represents global statistics from the game, such as the number of teams.</p> <p>Note</p> <p>Like the other statistics endpoints, this data is quite unstructured, and is best described with the following: <pre><code>type GameStatisticsResponse = HashMap&lt;uuid::Uuid, HashMap&lt;String, HashMap&lt;String, f64&gt;&gt;&gt;;\n</code></pre> The <code>uuid::Uuid</code> type can be substituted for <code>String</code> if your language doesn't have a specific type for <code>UUID</code>s.</p>"},{"location":"backend/http-api/#get-statistics-stats","title":"Get statistics stats","text":"<p>Example</p> <pre><code>GET https://api.nucleoid.xyz/stats/stats\n\n{\n    \"unique_players\": 141,\n    \"games_played\": 540,\n    \"entries\": {\n        \"player\": 10125,\n        \"global\": 0,\n        \"total\": 10125\n    },\n    \"grand_total\": {\n        \"player\": 662742.2732343078,\n        \"global\": 0,\n        \"total\": 662742.2732343078\n    }\n}\n</code></pre> <p>Returns some information about the amount of statistics that have been recorded in total.</p>"},{"location":"backend/http-api/#leaderboards","title":"Leaderboards","text":""},{"location":"backend/http-api/#get-leaderboard","title":"Get leaderboard","text":"<p>Example</p> <pre><code>GET https://api.nucleoid.xyz/leaderboard/nucleoid:games_played\n\n[\n    {\n        \"player\": \"0529de78-7795-4382-ba3c-350fe3159cc3\",\n        \"ranking\": 1,\n        \"value\": 151\n    },\n    {\n        \"player\": \"c705fc7d-0962-4d1e-905b-b83d81d9b4ec\",\n        \"ranking\": 2,\n        \"value\": 136\n    },\n    {\n        \"player\": \"c40d10d3-f2ee-47a6-92ec-63b53b6fdf01\",\n        \"ranking\": 3,\n        \"value\": 109\n    },\n    ...\n]\n</code></pre> <p>Returns the top 10 of the specified leaderboard.</p>"},{"location":"backend/http-api/#leaderboard-entry-object","title":"Leaderboard entry object","text":"Field Description <code>player</code> The UUID of the player <code>ranking</code> The player's position in the leaderboard <code>value</code> The score/statistic value the player has in this leaderboard <p>Warning</p> <p>This endpoint may be changed in future to allow querying a specific section of the leaderboard.</p>"},{"location":"backend/http-api/#get-player-rankings","title":"Get player rankings","text":"<p>Example</p> <pre><code>GET https://api.nucleoid.xyz/player/5ad3ab57b55646359ba99a9a0568965a/rankings\n\n{\n    \"nucleoid:games_played\": [34, 15],\n    \"destroy_the_monument:games_won\": [14, 1],\n    \"destroy_the_monument:total_kills\": [19, 8],\n    \"destroy_the_monument:damage_dealt\": [19, 237.21775656938553],\n    \"electricfloor:longest_time\": [27, 70.85],\n    \"electricfloor:blocks_converted\": [15, 536]\n}\n</code></pre> <p>Allows for querying a player's locations in the leaderboards. Each item in the returned item corresponds to one leaderboard, and the value is a pair, <code>[ranking, value]</code>, which have the same meaning as in the Leaderboard entry object</p>"},{"location":"build-rush/","title":"About","text":"<p>Build Rush is a build memorizing minigame for Minecraft! The goal is to memorize a structure and then rebuild it as fast and as correct as possible.</p> <p>Info</p> <p>This tutorial is currently updated for Build Rush 3.0.x.</p>"},{"location":"build-rush/builds/","title":"Adding a build","text":""},{"location":"build-rush/builds/#building-and-saving-the-structure","title":"Building and saving the structure","text":"<p>Warning</p> <p>You need to know how to use the structure block and its SAVE mode to create a build.</p> <p>First off, you need to build your structure in any creative world that you can download generated structures from. Either in a single-player world, or in a server that allows you to do so.</p> <p>Tip</p> <p>If you have access to the Nucleoid build server, you can join the original builds map <code>/map join buildrush:builds</code>. This map contains all the builds that were made by fellow Nucleoid contributors up to 3.0.0.</p> <p>To download any generated build on the Nucleoid build server, visit this site: https://build.nucleoid.xyz/</p> <p>You also need to choose a size for your build. Builds must have the same width, length and height. Let's say you want a size of <code>n</code> blocks for you build. This means you need to create a structure of dimensions <code>n</code>x<code>n</code>x<code>n</code>.</p> <p>You can also add a custom floor for your build, allowing the structure to be <code>n</code>x<code>n+1</code>x<code>n</code>. Players won't have to build this floor, as it will replace the floor of all plots when building. Please make sure that all blocks of the floor have a solid top surface.</p> <p>Tip</p> <p>Do not worry about falling blocks like sand for you floor, as barrier blocks will be placed under the plot floors if the map does not have blocks there.</p> <p>Example</p> <p>If you want to create a build of size 7, you can create a structure of dimensions 7x8x7, with the floor being at the bottom of the structure. If you do not want this floor, you can create a structure of dimensions 7x7x7.</p> <p>After finishing your build, save it using the structure block. The name of the structure file can be renamed manually afterward. Entities are not supported, so make sure to not include them while saving.</p> <p>Structures are stored under the <code>structures</code> folder of the datapack, so save it there when you're done.</p>"},{"location":"build-rush/builds/#creating-the-build-file","title":"Creating the build file","text":"<p>You now need to add a build configuration that will add information about your build. Builds are stored in the <code>build_rush/builds</code> folder of the datapack, so create a <code>.json</code> file there.</p> <p>Here are the configuration fields of a build: <pre><code>{\n  \"structure\": \"build_rush:build/my_build\",\n  \"name\": {\n    \"translate\": \"build.my_build\"\n  },\n  \"author\": {\n    \"name\": \"jeb_\",\n    \"uuid\": \"853c80ef-3c37-49fd-aa49-938b674adae6\"\n  }\n}\n</code></pre></p> Field Description Required Defaults to <code>structure</code> The path to the structure file. Yes <code>name</code> The name of the build. Yes <code>author</code> The author of the build. No <code>author.name</code> The name of the author. Yes <code>author.uuid</code> The UUID of the author. No <p>Tip</p> <p>If a game tries to load any build that is not valid in any way, it will get ignored and a warning will be sent in the console.</p> <p>A standalone build will not get used in any gamemode, that's because it is the game config that defines the list of builds that it's going to use. However, you can add your build to the <code>build_rush:generic</code> tag, which is used by the generic game modes.</p>"},{"location":"build-rush/builds/#notes-on-contributions","title":"Notes on contributions","text":"<p>If you are contributing to the Build Rush repository, please make sure to follow this checklist before submitting your pull request: - Your build is replicable in normal gameplay, on any maps. (no floating blocks) - Your build features as less redstone mechanics as possible. - If the name of your build is already used, add an underscore and a number at the end of the name. (<code>build</code>, <code>build_2</code>, <code>build_3</code>, ...) - Your structure file and your build configuration have the same name. - The structure is saved under the <code>structures/builds</code> folder inside the <code>build_rush</code> datapack. - If the build is not made for specific gamemode, add it to the <code>build_rush:generic</code> build tag. - The build name is translatable. Use existing translations if possible, if not add a translation key that follows the <code>build.&lt;name&gt;</code> pattern.</p> <p>Warning</p> <p>Currently, the generic game modes of Build Rush were made for build sizes of 5, 7 and 9. Only size 5 is used for now though. </p>"},{"location":"build-rush/maps/","title":"Adding a map","text":""},{"location":"build-rush/maps/#creating-the-map-template","title":"Creating the map template","text":"<p>Please follow the Plasmid tutorial on how to create a map template.</p> <p>A Build Rush map template needs the following regions: - <code>center_plot</code>: the center of the map, where the players will be teleported to at first, and where the chosen build may appear at points. (only 1) - <code>plot</code>: the plots where the players will build. There must be at least as many plots as the max amount of players in the game configuration (see below).</p> <p>A map can only support one size of builds. The size of the chosen builds is determined by the size of the plots.</p> <p>All plots must be of the same size (width and length) and be 1 block high.</p> <p>Tip</p> <p>If you get anything wrong with your map, the game will not start. You can check the logs to see what went wrong.</p> <p>Map templates are stored in the <code>map_templates</code> folder of the datapack, so save it there when you're done.</p>"},{"location":"build-rush/maps/#creating-the-game-configuration","title":"Creating the game configuration","text":"<p>Please follow the Plasmid tutorial on how to create a game configuration.</p> <p>You now need to add a game configuration that will use your map. Game configurations are stored in the <code>games</code> folder of the datapack, so create your <code>.json</code> file there.</p> <p>Here are the configuration fields added by Build Rush, on top of the ones added by Plasmid:  <pre><code>{\n  // ...\n  \"players\": {\n    \"min\": 1,\n    \"threshold\": 8,\n    \"max\": 16\n  },\n  \"map\": {\n    \"template\": \"build_rush:my_map\",\n    \"nametag_offset\": 5,\n    \"nametag_size\": 2.0\n  },\n  \"builds\": \"#build_rush:generic\"\n  // ...\n}\n</code></pre></p> <p>The game type is <code>build_rush:standard</code>.</p> Field Description Required Defaults to <code>players</code> The configuration of number of players. Yes <code>map</code> The configuration of the map. Yes <code>map.template</code> The map template to use. Yes <code>map.nametag_offset</code> The offset of the name tag above the player's plot. No 10 <code>map.nametag_size</code> The size of the name tag above the player's plot. No 5.0 <code>builds</code> The list of builds to use. Can be a list of builds, or a tag. Yes <p>For the builds list, you can use the <code>#build_rush:generic</code> tag that includes most of the available builds.</p> <p>Note</p> <p>The builds field can contain any builds, even if they are not compatible with the map. Only compatible builds from the entry list will get used.</p>"},{"location":"build-rush/maps/#notes-on-contributions","title":"Notes on contributions","text":"<p>If you are contributing to the Build Rush repository, please make sure to follow this checklist before submitting your pull request: - Your map template and game configuration have the same name. - Your game configuration is in the correct subfolder: <code>small</code> is for maps compatible with 5x5 builds, <code>medium</code> is for 7x7, and <code>large</code> is for 9x9. - Your game configuration is listed in the <code>random</code> game configuration in the same subfolder. - The game configuration follows this example:   <pre><code>{\n  // ...\n  \"name\": {                                        \n    \"translate\": \"game.build_rush.small.with_map\",   // change \"small\" with \"medium\" or \"large\" depending on the size of your plots\n      \"with\": [\n      {\n        \"translate\": \"map.build_rush.my_map\"         // change \"my_map\" with the identifier of your map (and translate it in lang/en_us.json)\n      }\n    ]\n  },\n  \"icon\": \"minecraft:diamond\",                       // as your game will show up in the list of games, you need an item to represent it\n  // ...\n}\n</code></pre> - Your game configuration has an icon. - The build list is large enough, to counter the feeling of repetitiveness. Use the <code>#build_rush:generic</code> if you don't have enough builds.</p>"},{"location":"plasmid/","title":"About","text":"<p>Plasmid is a library and mod that forms the core of Nucleoid, providing a base to build minigames on top of.</p> <p>From the plasmid README</p> <p>Plasmid intends to do all the boring work relating to minigame implementation, to rather allow focus effort on just the game itself.</p> <p>Warning</p> <p>Current plasmid documentation is not up-to-date with the latest releases, including plasmid 0.5 for Minecraft 1.17.</p> <p>Note</p> <p>The current documentation is imported from the old GitHub wiki, and was originally written by Gegy.</p>"},{"location":"plasmid/getting-started/","title":"Getting Started","text":""},{"location":"plasmid/getting-started/#adding-to-gradle","title":"Adding to Gradle","text":"<p>Assuming you already have a Fabric workspace set up, the first step to setting up Plasmid will be adding it to your gradle buildscript. You will need to add the maven repository as well as the plasmid dependency. The Plasmid version should be replaced with the latest version from our versions page.</p> <p>Info</p> <p>This tutorial is currently updated for Plasmid 0.5.x.</p> <pre><code>repositories {\nmaven { url = 'https://maven.nucleoid.xyz/' }\n}\n\ndependencies {\n// ...\nmodImplementation 'xyz.nucleoid:plasmid:0.5+1.19-SNAPSHOT'\n}\n</code></pre>"},{"location":"plasmid/getting-started/#creating-a-game-type","title":"Creating a game type","text":"<p>A \"game type\" (<code>GameType</code>) is the entry-point to creating a game with Plasmid: they provide a unique identifier for your game, as well as all the information needed for it to be able to call your code when the game starts.</p> <p>Plasmid is designed to encourage data-driven games, and works with the concept of a \"game config\". A game config is essentially a specific variation of a game type! This may involve a different map to play on, or entirely different game mechanics. A game config is simply defined as a JSON file in a datapack that references your <code>GameType</code> and passes along any extra data that may be useful for configuring your game. While this may be a bit more work at first, it is very powerful in allowing games to be much easier to tweak or produce multiple variations of without duplicating code. More on configs later!</p> <p>To register a <code>GameType</code>, you will need to call <code>GameType.register()</code> in your <code>ModInitializer</code> class. A call to register a <code>GameType</code> may look something like: <pre><code>GameType.register(\nnew Identifier(\"plasmid_example\", \"example\"),\nExampleGameConfig.CODEC,\nExampleGame::open\n);\n</code></pre></p> <p>Let's break down what is going on here:</p> <ul> <li> <p><code>new Identifier(\"plasmid_example\", \"example\")</code></p> <ul> <li>declares the unique identifier for this game type that will be referenced by game config JSONs</li> </ul> </li> <li> <p><code>ExampleGameConfig.CODEC</code></p> <ul> <li>a <code>Codec</code> that will be used to load the game configuration from a JSON file (more on this later!)</li> </ul> </li> <li> <p><code>ExampleGame::open</code></p> <ul> <li>a method reference to a function that will be used to start your game when a player requests it</li> </ul> </li> </ul> <p>This naturally will not compile yet: neither <code>ExampleGame</code> nor <code>ExampleGameConfig</code> exist! Let's get to that.</p>"},{"location":"plasmid/getting-started/#creating-our-config-in-code","title":"Creating our config in code","text":"<p>First we will create our <code>ExampleGameConfig</code> class, which will hold a <code>String</code> field that will be used as a message to send to the player when they join. Java's new Records are perfect for configs, but not required!</p> <pre><code>public record ExampleGameConfig(String greeting) {\n}\n</code></pre> <p>That's simple enough! But we're missing the <code>CODEC</code> field that we referenced earlier. What is that about?</p> <p>A <code>Codec</code> is a very helpful tool implemented by Mojang's DataFixerUpper library that essentially allows for convenient serialization and deserialization of a Java object to a JSON file. A more detailed explanation of Codecs by Drullkus can be found here, but for simple purposes, all you need to know is the pattern for putting them together.</p> <p>Essentially, a Codec describes how an object is serialized and deserialized. Simply, they can be created from a list of fields and how those fields should be serialized. It goes like this: <pre><code>public record ExampleGameConfig(String greeting) {\npublic static final Codec&lt;ExampleGameConfig&gt; CODEC = RecordCodecBuilder.create(instance -&gt; {\nreturn instance.group(\nCodec.STRING.fieldOf(\"greeting\").forGetter(ExampleGameConfig::greeting)\n).apply(instance, ExampleGameConfig::new);\n});\n}\n</code></pre></p> <p>This will correspond to a JSON file that looks something like: <pre><code>{\n\"greeting\": \"Hello World!\"\n}\n</code></pre></p> <p>Most things here you can ignore: you only really need to worry about what's in the <code>instance.group(...)</code> call, and the generic on the Codec. To look at each relevant part more specifically:</p> <ul> <li> <p><code>Codec&lt;ExampleGameConfig&gt;</code></p> <ul> <li>The type of class that is being deserialized into is passed as a generic parameter to the <code>Codec</code>.</li> </ul> </li> <li> <p><code>Codec.STRING.fieldOf(...).forGetter(...)</code></p> <ul> <li> <p>This adds a field with a given name and type that will be read from the JSON.</p> </li> <li> <p>You will notice that <code>Codec.STRING</code> is itself a <code>Codec&lt;String&gt;</code>! Every field you declare will require a Codec to describe how that field should be handled. In this case, we're indicating that the greeting field should be loaded using <code>Codec.STRING</code>. In the same way, we could reference any other codec we create to add it as a field! This is very useful in allowing combinations of codecs to create complex structures!</p> <ul> <li>Codec tip: most serializable Minecraft types will hold a static <code>CODEC</code> field for use (e.g. <code>BlockPos.CODEC</code> or <code>Identifier.CODEC</code>). If not, we bundle a <code>MoreCodecs</code> type which provides some common ones that are not included in the vanilla codebase (e.g. <code>MoreCodecs.TEXT</code>).</li> </ul> </li> <li> <p>The parameter to <code>.fieldOf()</code> specifies the name of the field (in JSON) that this value will be read from.</p> </li> <li> <p><code>.forGetter()</code> specifies how the value of a field should be read back from our config object. This is useful since codecs allow for both serialization and deserialization, and the getter is required to turn the object back into data. We can use a method reference here since we're using a record.</p> </li> </ul> </li> <li> <p><code>ExampleGameConfig::new</code></p> <ul> <li> <p>This tells the codec how to create the object once all the fields have been deserialized. This requires a method reference to the constructor for the given object with all the fields in order as they were specified!.</p> </li> <li> <p>For example, if we passed <code>Codec.STRING.fieldOf(\"foo\")</code> and then <code>Codec.INT.fieldOf(\"bar)</code>, the constructor would take a <code>(String, int)</code>.</p> </li> <li> <p>But here we take in one <code>String</code> field, and the constructor we reference also takes a single <code>String</code> parameter.</p> </li> </ul> </li> </ul> <p>The end result of all this Codec work is that when we create a game config, all this data will be automatically parsed from our JSON file and passed to our game code!</p>"},{"location":"plasmid/getting-started/#creating-a-config","title":"Creating a config","text":"<p>Now that we know what data our config should hold, we can create an actual game config JSON for Plasmid to load.</p> <p>All game configs need to be located in your mod resources (or datapack!) at <code>data/&lt;namespace&gt;/games/&lt;id&gt;.json</code>. For the purpose of a mod, the <code>namespace</code> should just be your mod id, and the <code>id</code> can be any unique name that will later be used to reference your game config from inside Minecraft.</p> <p>Plasmid requires only 1 JSON field from the config, while the rest is loaded as per the config codec that you set up. There are however also some additional optional fields which may be useful to define. The only required field is the <code>type</code>, which refers to the <code>GameType</code> you created earlier in <code>namespace:path</code> format (e.g. in our case, <code>plasmid_example:example</code>).</p> <p>For our purposes, our game config at <code>data/plasmid_example/games/hello_world_example.json</code> will look like: <pre><code>{\n\"type\": \"plasmid_example:example\",\n\"greeting\": \"Hello, World!\"\n}\n</code></pre></p> <p>We can also add some additional builtin fields to our JSON such as a <code>name</code>, <code>short_name</code>, <code>description</code>, and <code>icon</code>. This may look like: <pre><code>{\n  \"type\": \"plasmid_example:example\",\n  \"name\": \"Hello World Example!\",\n  \"description\": [\"Look at my cool game!\", \"It greets you when you join.\"],\n  \"icon\": \"minecraft:apple\"\n  // ...\n}\n</code></pre></p> <p><code>name</code> and <code>description</code> can also reference translation keys due to being JSON Text Components. For example, this may instead be: <code>\"name\": {\"translation\": \"game.plasmid_example.hello_world_example\"}</code>.</p>"},{"location":"plasmid/getting-started/#a-note-on-translations","title":"A note on translations","text":"<p>Translations are a bit non-standard in Plasmid due to it being entirely server-side! Usually translations are stored with the game client, and the server simply sends over translation keys which are then turned into relevant readable text on the client-side. Here, however, we need to instead handle translations by changing the packets that get sent to players such that they are correctly translated before the client even receives it. This is a lot of work! Luckily, this is handled by Server Translations, and we do not need to worry about it!</p> <p>All this actually means for you is that your language files need to go in the <code>data</code> folder instead of the <code>assets</code> folder (e.g. <code>data/&lt;namespace&gt;/lang/en_us.json</code>).</p> <p>There are some default language keys we should worry about if we're not manually defining a name: <code>gameType.&lt;namespace&gt;.&lt;id&gt;</code> and <code>game.&lt;namespace&gt;.&lt;id&gt;</code>. These keys are applied for game types and game configs respectively. When resolving the readable name for a game config, both the config translation and type translation will be tested, with the type as a fallback. This means only the game type translation is strictly necessary.</p> <p>For example, we may define our <code>data/plasmid_example/lang/en_us.json</code> as: <pre><code>{\n\"gameType.plasmid_example.example\": \"Plasmid Example!\",\n\"game.plasmid_example.hello_world_example\": \"Hello World Example!\"\n}\n</code></pre></p>"},{"location":"plasmid/getting-started/#writing-the-code-to-start-our-game","title":"Writing the code to start our game","text":"<p>Now that we have set up a config and have told Plasmid how to read from it, we can finally write the code to actually start our game.</p> <p>For the purpose of this example, let's create an <code>ExampleGame</code> class. We will use this class to hold the state of the game as well as our <code>ExampleGameConfig</code> that got loaded. For now though, we just need to create this <code>open</code> function that we referenced to the <code>GameType</code>.</p> <p>This should look like: <pre><code>public class ExampleGame {\npublic static GameOpenProcedure open(GameOpenContext&lt;ExampleGameConfig&gt; context) {\n// get our config that got loaded by Plasmid\nExampleGameConfig config = context.config();\n\n// create a very simple map with a stone block at (0; 64; 0)\nMapTemplate template = MapTemplate.createEmpty();\ntemplate.setBlockState(new BlockPos(0, 64, 0), Blocks.STONE.getDefaultState());\n\n// create a chunk generator that will generate from this template that we just created\nTemplateChunkGenerator generator = new TemplateChunkGenerator(context.server(), template);\n\n// set up how the world that this minigame will take place in should be constructed\nRuntimeWorldConfig worldConfig = new RuntimeWorldConfig()\n.setGenerator(generator)\n.setTimeOfDay(6000);\n\nreturn context.openWithWorld(worldConfig, (activity, world) -&gt; {\n// to be implemented\n});\n}\n}\n</code></pre></p> <p>There is a lot to unpack here, but it's not too complex if we break it down. Our <code>open</code> will be called whenever a player starts this game. The function takes a <code>GameOpenContext</code>, which holds the data from our JSON config (<code>context.config()</code>), and must return a <code>GameOpenProcedure</code>, which instructs Plasmid how it should continue to set up the game. It is worth nothing that this function is run asynchronously on the thread pool, so it is safe to run whatever slow code here before the game starts.</p> <p>The <code>GameOpenProcedure</code> is created from the <code>GameOpenContext.openWithWorld</code> function, and takes in a <code>RuntimeWorldConfig</code> as well as a lambda that accepts a <code>GameActivity</code> and <code>ServerWorld</code>. A runtime world is a concept within Plasmid that represents the fully isolated and temporary world that the game takes place within. It is automatically deleted when the game finishes. When a player joins the game, their inventory will be cleared, and when they leave, it will be restored back to them. A game activity is a specific set of logic that is running within a game: this is what we will configure to change game behaviour. We can switch the activity within a game at any point.</p> <p>The <code>RuntimeWorldConfig</code> describes how this world should be created. The most important thing to be configured within here is the chunk generator: this tells the game how the world should generate. It would be possible to, for example, pass the overworld chunk generator here, but for our purpose, we're creating an empty world with a single stone block. This is handled through the convenience <code>TemplateChunkGenerator</code>: this takes a <code>MapTemplate</code>, which is just a very basic world that contains some blocks! The generator then loads from that into the world itself.</p> <p>Finally, we need to address what to do in the lambda with the <code>GameActivity</code> parameter. The code inside this lambda will run on the main server thread, and is used to run the actual game setup code. This mainly involves registering event listeners, or setting global rules.</p> <p>Event tip: we make use of Stimuli for handling many events in games, so any event from there can be used within Plasmid.</p> <p>For example: <pre><code>return context.openWithWorld(worldConfig, (activity, world) -&gt; {\nactivity.deny(GameRuleType.FALL_DAMAGE);\n\nactivity.listen(GamePlayerEvents.ADD, player -&gt; {\n// a player has been added!\n});\n});\n</code></pre></p> <p>This code will disable fall damage for all players, as well as registering an event listener that will be called whenever a player is added to this game.</p> <p>However! Before we give functionality to our brilliant example game, we need to respond to the player offer event listener. This is called before any player joins the game, and is able to accept or reject that join request. Most critically, the listener defines how and where the player should be spawned into our game world.</p> <p>An example offer listener may look like: <pre><code>activity.listen(GamePlayerEvents.OFFER, offer -&gt; {\nServerPlayerEntity player = offer.player();\nreturn offer.accept(world, new Vec3d(0.0, 64.0, 0.0))\n.and(() -&gt; {\nplayer.changeGameMode(GameMode.ADVENTURE);\n});\n});\n</code></pre></p> <p>That's a lot! Let's break it down:</p> <ul> <li> <p>We register a listener for <code>GamePlayerEvents.OFFER</code> which takes an <code>offer</code> parameter.</p> </li> <li> <p>We get the player instance who is trying to join from the offer.</p> </li> <li> <p>We call <code>offer.accept(...)</code> to accept the player into the game.</p> <ul> <li>We pass the accept function a world and a position for the player to be teleported to. The world was passed to us above by Plasmid!</li> </ul> </li> <li> <p>We then call <code>.and(...)</code> on the result of <code>.accept(...)</code> in order to attach some additional spawn logic to be run when the player joins. In this case, that is to set the player's game mode to adventure mode as they join.</p> </li> </ul> <p>Now that we have that set up, we can return to our player add listener: as of right now, we're not doing anything when it is called. We want it to send a greeting to the player when they join. Let's implement that: <pre><code>GameSpace gameSpace = activity.getGameSpace();\nactivity.listen(GamePlayerEvents.ADD, player -&gt; {\nText message = Text.literal(config.greeting);\ngameSpace.getPlayers().sendMessage(message);\n});\n</code></pre></p> <p>So we've added logic to send a message within the listener, but what is a <code>GameSpace</code>? A <code>GameSpace</code> is a concept introduced by Plasmid which, as the name implies, represents the space within which a game is occurring. For all our purposes, that space is just this one dimension that the game is playing within. The <code>GameSpace</code> is useful for us in that it keeps track of all the players within it, as well as the <code>ServerWorld</code> that the game is taking place within. Here, we access the <code>GameSpace</code> through <code>GameActivity.getGameSpace()</code>.</p> <p>Working with players additionally goes through a different Plasmid API: a <code>PlayerSet</code>. A <code>PlayerSet</code> represents just a list of players, and it can be iterated over or queried, but additionally provides utilities for performing bulk operations over many players. For example, sending a message! Here, we use <code>PlayerSet.sendMessage()</code> to send our greeting to every player within the game.</p> <p>Tada! \ud83c\udf89 We have a working game! But before we test it, let's do some minor reorganization. With all these handlers and lambdas, our code inside <code>createOpenProcedure</code> is going to get quite lengthy very quickly! It would be nice if we can put all event listeners on our <code>ExampleGame</code> object instead.</p> <p>Turns out, that works just fine, and we are left with our final <code>ExampleGame</code> setup: <pre><code>public final class ExampleGame {\nprivate final ExampleGameConfig config;\nprivate final GameSpace gameSpace;\nprivate final ServerWorld world;\n\npublic ExampleGame(ExampleGameConfig config, GameSpace gameSpace, ServerWorld world) {\nthis.config = config;\nthis.gameSpace = gameSpace;\nthis.world = world;\n}\n\npublic static GameOpenProcedure open(GameOpenContext&lt;ExampleGameConfig&gt; context) {\n// get our config that got loaded by Plasmid\nExampleGameConfig config = context.config();\n\n// create a very simple map with a stone block at (0; 64; 0)\nMapTemplate template = MapTemplate.createEmpty();\ntemplate.setBlockState(new BlockPos(0, 64, 0), Blocks.STONE.getDefaultState());\n\n// create a chunk generator that will generate from this template that we just created\nTemplateChunkGenerator generator = new TemplateChunkGenerator(context.server(), template);\n\n// set up how the world that this minigame will take place in should be constructed\nRuntimeWorldConfig worldConfig = new RuntimeWorldConfig()\n.setGenerator(generator)\n.setTimeOfDay(6000);\n\nreturn context.openWithWorld(worldConfig, (activity, world) -&gt; {\nExampleGame game = new ExampleGame(config, activity.getGameSpace(), world);\n\nactivity.deny(GameRuleType.FALL_DAMAGE);\nactivity.listen(GamePlayerEvents.OFFER, game::onPlayerOffer);\nactivity.listen(GamePlayerEvents.ADD, game::onPlayerAdd);\n});\n}\n\nprivate PlayerOfferResult onPlayerOffer(PlayerOffer offer) {\nServerPlayerEntity player = offer.player();\nreturn offer.accept(this.world, new Vec3d(0.0, 64.0, 0.0))\n.and(() -&gt; {\nplayer.changeGameMode(GameMode.ADVENTURE);\n});\n}\n\nprivate void onPlayerAdd(ServerPlayerEntity player) {\nText message = Text.literal(this.config.greeting);\nthis.gameSpace.getPlayers().sendMessage(message);\n}\n}\n</code></pre></p>"},{"location":"plasmid/getting-started/#testing-the-game","title":"Testing the game!","text":"<p>Once everything compiles, we can finally launch up Minecraft. If our <code>GameType</code> is all correctly set up and game config JSON in place, once opening a world, we should be able to start our game by running: <code>/game open &lt;id&gt;</code>. (Remember, this is referencing the name of the JSON file and not the GameType!)</p> <p>So in our case: <code>/game open plasmid_example:hello_world_example</code> ...and we should be joined into our void world with a stone block with a lovely greeting!</p> <p>Now, any other player can join us too by running <code>/game join</code> or clicking the link that shows up in chat.</p> <p>That's it! \ud83c\udf89 </p>"},{"location":"plasmid/maps/","title":"Creating a Map","text":"<p>Any minigame needs a map for the game to take place within. This may be generated by your code- but most often, you just want to use a map that you built by hand. Plasmid introduces various tools which can be used in order to accomplish this. This page will address specifically the process of building the map and attaching various metadata that may be needed for the game to function through Map Workspaces.</p> <p>NOTE: The map tools have been moved to a separate mod called \"Nucleoid Creator Tools\", you can install those tools here.</p>"},{"location":"plasmid/maps/#opening-a-workspace","title":"Opening a workspace","text":"<p>The first step to creating a map is opening a map workspace. A map workspace is essentially just a dimension that you can build within, which can later be exported into a map template file readable by Plasmid.</p> <p>An empty void map workspace can be opened by running: <code>/map open &lt;id&gt;</code> (e.g. <code>/map open bedwars:cubes</code>) The required <code>id</code> is a unique identifier for your workspace in <code>namespace:identifier</code> format. It should be all lowercase and cannot have spaces.</p> <p>You are also able to create workspaces with custom chunk generators: <code>/map open &lt;id&gt; like &lt;dimension&gt;</code> (e.g. <code>/map open bedwars:nether like minecraft:nether</code>)</p>"},{"location":"plasmid/maps/#moving-in-and-out-of-workspaces","title":"Moving in and out of workspaces","text":"<p>Once you have created a workspace, you need to be able travel between them.</p> <p>This is possible by running: <code>/map join &lt;id&gt;</code>, which will teleport you into that workspace dimension. Once you are in the workspace dimension, you are free to build whatever you want!</p> <p>Likewise, it is possible to leave a map workspace and return to your former location by running: <code>/map leave</code>.</p>"},{"location":"plasmid/maps/#setting-the-map-bounds","title":"Setting the map bounds","text":"<p>When exporting a map to be loaded into a game, Plasmid needs to know the area of the world which should be included. This is controlled by setting a box that encompasses your map.</p> <p>When you first enter a workspace, you will notice a box outline formed by particles- these are your map bounds! They can be changed in a workspace by running: <code>/map bounds &lt;id&gt; &lt;corner_1&gt; &lt;corner_2&gt;</code>.   - <code>id</code> is the workspace id to set bounds for   - <code>corner_1</code> and <code>corner_2</code> are the two corners of the axis-aligned bounding box</p>"},{"location":"plasmid/maps/#setting-the-map-origin","title":"Setting the map origin","text":"<p>More often than not, you will not need to change the origin of a map workspace. Essentially, though, the map origin controls the block position that will correspond to (0; 0; 0) once the map is exported. This is useful if you built your map in the wrong place, and want to move it when the game actually starts.</p> <p>For example, if your map is 10 blocks too high, setting your origin to <code>(0; 10; 0)</code> will result in the exported map moving 10 blocks downward.</p> <p>This can be set through <code>/map origin &lt;id&gt; &lt;origin&gt;</code>   - <code>id</code> is the workspace id to set the origin for   - <code>origin</code> is the block position to set the origin to</p> <p>Be careful when setting origin to not cause your map to go out of bounds! If you set your map origin somewhere below the lower y of your map bounds, that will mean in the exported map, your bounds will be going below y=0!</p>"},{"location":"plasmid/maps/#working-with-regions","title":"Working with regions","text":"<p>Having a map that we can load for a minigame is useful, but the game logic is missing any sort of useful information about the map. For example, how can your minigame know where to spawn players, or where the bed for a specific team in bedwars is located?</p> <p>This is where regions come in: a region is just a named area of the map which can be used to communicate to the game code an area in which something should happen. There can be multiple regions in the map with the same name, or multiple regions with different names in the same location. The naming of regions is useful in order to identify to the game code what each region represents.</p>"},{"location":"plasmid/maps/#creating-a-region","title":"Creating a region","text":"<p>To get started with creating a region, run: <code>/give @s plasmid:add_region</code>. This gives you the Add Region item, which can be used to easily define regions within your world by selecting two corners.</p> <p>By right clicking on a block, a particle box should appear. This starts the process of defining a region by selecting the first corner. Now, as you look around, the box will shape to match the second corner. Right clicking a second time will select the current looked-at block as the second corner.</p> <p>Now, you can run <code>/map region commit &lt;marker&gt;</code>. This will add the highlighted region to your map with the given <code>marker</code>, and it should highlight with differently colored particles.</p> <p>When selecting a region with the Add Region item, you can additionally change the selection mode by sneaking &amp; right clicking. This cycles through 3 modes:   - offset mode: the highlighted block is the block you are looking at, offset by the side you are looking at it from (like placing a block)   - exact mode: the highlighted block is the exact block your are looking at (like breaking a block)   - at feet mode: the highlighted block is the block at your feet</p>"},{"location":"plasmid/maps/#useful-region-commands","title":"Useful region commands","text":"<ul> <li><code>/map region rename all &lt;old&gt; &lt;new&gt;</code>: renames all regions in the current workspace from <code>old</code> to <code>new</code></li> <li><code>/map region rename here &lt;old&gt; &lt;new&gt;</code>: renames all regions intersecting with your player in the current workspace from <code>old</code> to <code>new</code></li> <li><code>/map region remove here</code>:  removes all regions intersecting with your player from the current workspace</li> <li><code>/map region remove at &lt;pos&gt;</code>: removes all regions intersecting with the given <code>pos</code> from the current workspace</li> </ul>"},{"location":"plasmid/maps/#attaching-data","title":"Attaching data","text":"<p>It may desirable to communicate more information about the map to the code than just regions. This can be done by attaching arbitrary NBT data which is later accessible by the code.</p> <p>Data can be either attached to a region or to the map as a whole.</p> <p>To work with data on a specific region, your player must be intersecting that region's bounds!   - <code>/map region data &lt;marker&gt; get</code>: prints the data for the given region   - <code>/map region data &lt;marker&gt; set &lt;data&gt;</code>: sets the data for the given region (this will overwrite any previously existing data!)   - <code>/map region data &lt;marker&gt; merge &lt;data&gt;</code>: merges the given data with the existing data on the given region</p> <p>It is additionally possible to pass data to the region commit command: <code>/map region commit &lt;marker&gt; &lt;data&gt;</code></p> <p>To work with data on the global map, the commands function similarly:   - <code>/map data get</code>: prints the data attached to the map   - <code>/map data set &lt;data&gt;</code>: overwrites the existing data on the map   - <code>/map data merge &lt;data&gt;</code>: merges the given data with the existing data on the map</p>"},{"location":"plasmid/maps/#exporting-maps","title":"Exporting maps","text":"<p>Once your map is complete, you will want to export it into a file that can be loaded by Plasmid. This can be done simply by running: <code>/map export &lt;id&gt;</code>.</p> <p>The exported map will be placed in <code>/plasmid/exports/&lt;namespace&gt;/map_templates/&lt;path&gt;.nbt</code></p>"},{"location":"plasmid/statistics/","title":"Implementing statistics","text":"<p>Warning</p> <p>The final statistics API is only available on Plasmid 0.5 for 1.17 and higher, as some things have changed since the initial implementation in Plasmid 0.4</p> <p>Plasmid provides an API for allowing minigames to record statistics for their players, and can be implemented to allow leaderboards to be generated for games (soon\u2122).</p>"},{"location":"plasmid/statistics/#before-you-begin","title":"Before you begin","text":"<p>This guide assumes that you have a minigame already implemented and want to add support for tracking statistics. If you simply would like to create a minigame, see the Getting Started guide.</p> <p>It also expects that you are on the latest version of Plasmid 0.5 with statistics support.</p>"},{"location":"plasmid/statistics/#bundles-of-fun","title":"Bundles of fun","text":"<p>(Well it might not seem fun, but its the first step for implementing statistics into your game.)</p> <p>The first step for implementing statistics is getting your hands on a <code>GameStatisticBundle</code>, which is a class provided by plasmid that holds per-player and global statistics for your current game. You can do this quite easily within the constructor of your <code>GameActive</code> class like this: <pre><code>public class MyGameActive {\n/* other fields */\npublic final GameStatisticBundle statistics;\n\nprivate MyGameActive(GameSpace gameSpace, /* other parameters */) {\n/* other initialization logic */\n\n// The value passed to getStatistics should usually be the ID of your minigame/mod\nthis.statistics = gameSpace.getStatistics().bundle(MyGame.ID);\n}\n\n/* other game logic */\n}\n</code></pre></p> <p>You also need to provide a translation for the name of your bundle, with the translation key in the form <code>statistic.bundle.&lt;namespace&gt;</code>. This <code>namespace</code> is whatever you passed into <code>gameSpace.getStatistics().bundle()</code>, so double check it matches.</p>"},{"location":"plasmid/statistics/#getting-some-keys","title":"Getting some keys","text":"<p>Time to get implementi- Oh, we still need to do something else first :/</p> <p>Once you have a <code>GameStatisticsBundle</code>, the next step is to actually increment some statistics, and this is where the specifics can become different between games, as every game is somewhat unique.</p> <p>What are StatisticKeys?</p> <p><code>StatisticKey</code>s are a type-safe identifier for a specific statistic, and internally store both an <code>Identifier</code>.</p>"},{"location":"plasmid/statistics/#standard-keys","title":"Standard keys","text":"<p>Plasmid provides several built in <code>StatisticKey</code>s in a conveniently named <code>StatisticKeys</code> class. Here are some examples:</p> <ul> <li><code>GAMES_PLAYED</code></li> <li><code>KILLS</code></li> <li><code>DAMAGE_DEALT</code></li> <li><code>QUICKEST_TIME</code></li> </ul>"},{"location":"plasmid/statistics/#custom-keys","title":"Custom keys","text":"<p>You can create your own <code>StatisticKey</code>s and store them in <code>public static final</code> fields in a dedicated class, usually named something like <code>MyGameStatistics</code>. <pre><code>public class MyGameStatistics {\npublic static final StatisticKey&lt;Integer&gt; SOME_COOL_STAT =\n// or StatisticKey.doubleKey or StatisticKey.floatKey\nStatisticKey.intKey(new Identifier(MyGame.ID, \"some_cool_stat\"));\n}\n</code></pre></p> <p>If you implement custom keys, you need to ensure you provide translations for their names, in the form <code>statistic.&lt;id namespace&gt;.&lt;id path&gt;</code>, where <code>id namespace</code> and <code>id path</code> are the namespace and path of the <code>Identifier</code> you passed as the first argument when creating the key.</p> <p>Tip</p> <p>If you think other minigames could use a custom <code>StatisticKey</code> you implement, mention it in <code>#tools-and-libraries</code> on Discord and it might get included in plasmid's <code>StatisticKeys</code> class.</p>"},{"location":"plasmid/statistics/#incrementing-statistics","title":"Incrementing statistics","text":"<p>Now for the actually interesting part.</p> <p>Global and per-player statistics</p> <p>Per-player statistics are fairly self-explanatory; they're things like <code>KILLS</code> or <code>QUICKEST_TIME</code> that apply to a single player. Global statistics are a little different, as their values are not associated with a particular player, but with the entire game session. Global statistics can be used to store things like the number of teams in the game or the length of a course.</p> <p>Incrementing the statistics uses a fluent API style like the following: <pre><code>// For a player\nthis.statistics.forPlayer(player).increment(StatisticKeys.DEATHS, 1);\n// Or a global statistic\nthis.statistics.global().set(MyGameStatistics.TEAM_COUNT, 5);\n</code></pre> <code>player</code> can be either a <code>UUID</code>, <code>PlayerRef</code> or <code>ServerPlayerEntity</code>.</p> <p>The final step is to scatter these increments around your minigame and collect statistics for whatever seems interesting for players.</p>"},{"location":"plasmid/statistics/#finished","title":"Finished!","text":"<p>And then that's it, your minigame now has statistics support \ud83c\udf89!</p> <p>If you need a hand implementing or don't understand something, feel free to join the Discord and ask in <code>#minigame-dev</code>.</p>"},{"location":"plasmid/statistics/#extra-debugging","title":"Extra: debugging","text":"<p>If you want to double-check that your statistics are being counted correctly, you can add <code>-Dplasmid.debug_statistics=true</code> to your JVM arguments and plasmid will print out a JSON formatted version of all <code>GameStatisticBundle</code>s at the end of any game.</p>"}]}