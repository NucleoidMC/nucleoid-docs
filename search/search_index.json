{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome!","text":"<p>Here you can find documentation about Nucleoid's libraries and other tools. Have a look in the navigation bar to find what you are looking for.</p> <p>If you want to get started making a minigame, you probably want to look at Plasmid. If you want to contribute translations, see our Weblate. You can also come and chat to us on Discord in the <code>#minigame-dev</code> channel!</p>"},{"location":"admin/","title":"About","text":"<p>This section of the docs is for information about running the Nucleoid Minecraft server itself.</p>"},{"location":"admin/guides/new-contributor/","title":"New contributors","text":"<p>Things to do for new contributors.</p>"},{"location":"admin/guides/new-contributor/#build-contributors","title":"Build contributors","text":"<ul> <li>Grant them OP on the build server (feel free to give this out to anyone, the server has frequent backups)</li> </ul>"},{"location":"admin/guides/new-contributor/#code-contributors","title":"Code contributors","text":"<ul> <li>Invite them to the GitHub organisation, and encourage minigame repositories that are going on the main server to be transfered to the org.</li> </ul>"},{"location":"admin/guides/new-contributor/#assigning-roles","title":"Assigning roles","text":"<p>Try to complete all of these when you get the chance</p>"},{"location":"admin/guides/new-contributor/#discord","title":"Discord","text":"<p>Grant them the contributor role, along with whichever specific roles fit (eg. code contributor, build contributor, translations contributor, etc).</p>"},{"location":"admin/guides/new-contributor/#in-game","title":"In game","text":"<pre><code>/role assign &lt;username&gt; contributor\n/role assign &lt;username&gt; dev # if they are a code contributor\n/role assign &lt;username&gt; builder # if they are a build contributor\n</code></pre>"},{"location":"admin/guides/new-contributor/#website-cards","title":"Website cards","text":"<ol> <li>Create a new file in the <code>NucleoidMC/nucleoid-contributors</code>, under the folder <code>data/people/</code> named <code>theirusername.toml</code> (use all lower case, and no spaces or special characters).</li> <li>Fill out the file using the following template: <pre><code>name = \"their preferred display name (if unsure, ask)\"\ngroups = [\n    \"code\",\n    \"building\",\n    \"art\",\n    \"community\",\n    \"translations\",\n    \"contributor\", # generic contributor role, should only be added if none of the others apply\n]\n\n[socials]\nminecraft = \"their minecraft uuid (for consistency, remove the -)\"\n</code></pre></li> <li>Commit the file back to the repo, and run <code>sudo git pull</code> in <code>/var/www/nucleoid-contributors</code> (unfortunately we don't have auto-deployment yet, poke Ash to set it up if you get annoyed by this).</li> <li>Invite them to update the file (or if they're not familiar with GitHub, provide extras for you to put in) - see Ash's card as a template. Members of the GitHub org should automatically get write permissions to the repo, so can update their own.</li> </ol>"},{"location":"admin/guides/reboot/","title":"What to do after a reboot","text":"<p>A short guide on making Nucleoid run again.</p>"},{"location":"admin/guides/reboot/#ensure-stuff-that-is-supposed-to-auto-run-did-actually-auto-run","title":"Ensure stuff that is supposed to auto run did actually auto-run","text":"<p>Run <code>sudo systemctl status</code> and check that the overall status is not <code>Degraded</code>. If it is, run <code>sudo systemctl</code>, and find the failed services.</p>"},{"location":"admin/guides/reboot/#start-up-standalone-services","title":"Start up standalone services","text":"<p>Switch to the <code>minecraft</code> user with <code>sudo su minecraft -s /usr/bin/fish</code>, and start up the following services under screen (<code>screen -R &lt;name of service&gt;</code>) in the following order:</p> Service Path Launch command mitosis <code>/home/minecraft/services/mitosis</code> <code>env RUST_LOG=info ./mitosis</code> face-api <code>/home/minecraft/services/face-api</code> <code>./player-face-api</code> backend <code>/home/minecraft/services/backend</code> <code>env RUST_LOG=nucleoid_backend=info ./nucleoid-backend</code> <p>Poke Ash and maybe she can turn some of these into systemd services.</p>"},{"location":"admin/guides/reboot/#stats-website","title":"Stats website","text":"<p>As the <code>minecraft</code> user, go into <code>/home/minecraft/services/stats</code> and run <code>docker compose start</code>.</p>"},{"location":"admin/guides/reboot/#minecraft-servers","title":"Minecraft servers","text":"<p>Using the same <code>screen</code> commands, as the <code>minecraft</code> user, run <code>./server-wrapper</code> inside each server directory:</p> <ul> <li><code>/home/minecraft/servers/play</code></li> <li><code>/home/minecraft/servers/build</code></li> </ul>"},{"location":"admin/guides/reboot/#velocity","title":"Velocity","text":"<p>In a <code>screen</code> session as the <code>minecraft</code> user, <code>cd</code> into <code>/home/minecraft/servers/proxy</code> and run <code>java -Xmx256M velocity.jar</code>.</p>"},{"location":"admin/guides/reboot/#bonus-modmail","title":"BONUS: Modmail","text":"<p><code>docker compose start</code> in <code>/home/ash/modmail</code> (please make Ash move it out of her home directory at some point)</p>"},{"location":"admin/guides/reboot/#testing-everything-is-working","title":"Testing everything is working","text":"<p>First, head to https://nucleoid.xyz and check the contributors section loads correctly and that Minecraft avatars are working.</p> <p>Then, check on https://stats.nucleoid.xyz/leaderboards that the list has loaded correctly, and that the translations have been loaded.</p>"},{"location":"admin/infra/","title":"About","text":"<p>This section contains details about running and maintaining Nucleoid's infrastructure.</p>"},{"location":"admin/infra/services/backend/","title":"Backend","text":"<p>The backend is run from <code>/home/minecraft/services/backend/</code>, using <code>screen</code> as the <code>minecraft</code> user.</p>"},{"location":"admin/infra/services/backend/#updating","title":"Updating","text":"<p>Download the latest binary from GitHub Actions (I use the <code>gh</code> cli for this), and put move it to <code>/home/minecraft/services/backend/nucleoid-backend</code>. Then connect to the backend <code>screen</code> session, ctrl-c and re-run the backend.</p>"},{"location":"admin/infra/services/minecraft/","title":"Minecraft","text":"<p>The two Minecraft servers are in <code>/home/minecraft/servers/{play,build}</code>. There is also a Velocity proxy in <code>/home/minecraft/servers/proxy</code>.</p>"},{"location":"admin/infra/services/minecraft/#addingupdating-mods","title":"Adding/updating mods","text":"<p>Most mods should auto-update from GitHub Actions. Other mods like Fabric API don't and the version has to be updated manually in <code>destinations.toml</code> (inside the server directory).</p>"},{"location":"admin/infra/services/minecraft/#velocity","title":"Velocity","text":"<p>As we often lag behind the latest releases of Minecraft, our Velocity proxy also has ViaVersion installed, to allow players on the latest version to join, even if we haven't updated yet.</p>"},{"location":"admin/infra/services/minecraft/#updates","title":"Updates","text":"<p>Updating Velocity is as simple as downloading the latest JAR file, and replacing <code>velocity.jar</code> in <code>/home/minecraft/servers/proxy</code> (make sure to update any plugins too). When restarting Velocity, wait until there are no players online, or ask them to stop after the next game.</p>"},{"location":"admin/infra/services/misc/","title":"Other services","text":"<p>I have undoubtedly forgotten something, if you notice anything is missing, poke Ash on Discord.</p>"},{"location":"admin/infra/services/misc/#grafana","title":"Grafana","text":"<p>Installed through APT, uses GitHub for logins and pulls data from postgres (which is written to by backend).</p>"},{"location":"admin/infra/services/misc/#databases","title":"Databases","text":"<p>Make sure both of these are running before you try to start backend, otherwise it won't work.</p>"},{"location":"admin/infra/services/misc/#postgresql","title":"Postgresql","text":"<p>If you have to update this to a new major version, good luck - Google is your friend.</p>"},{"location":"admin/infra/services/misc/#clickhouse","title":"Clickhouse","text":"<p>Every single update seems to change the default config file, which means apt/dpkg will ask you how to resolve it. When you do, take all the changes from the new config, and re-apply our specific parts (mainly disabling some of the logs as they take up a lot of storage).</p>"},{"location":"admin/infra/services/misc/#mitosis-and-face-api","title":"Mitosis and face-api","text":"<p>These are just small standalone serivces, managed in basically the same way as backend.</p>"},{"location":"admin/infra/services/modmail/","title":"Modmail","text":"<p>We run a modmail bot for players to contact our moderators on Discord, it is currently running from a docker-compose file in Ash's home directory.</p>"},{"location":"admin/infra/services/modmail/#updating","title":"Updating","text":"<p>To update, run <code>docker compose pull</code> to pull the new container image, then <code>docker compose down</code> to stop the existing instance, and finally <code>docker compose up --detatch</code> to restart it.</p>"},{"location":"admin/infra/services/website/","title":"Web services","text":""},{"location":"admin/infra/services/website/#nucleoidxyz","title":"nucleoid.xyz","text":"<p>The website is served as a static site by apache2 from <code>/var/www/nucleoid.xyz</code>. It's built automatically by GitHub Actions, so you just need to <code>sudo git pull</code> from that folder to update the site once it has built.</p>"},{"location":"admin/infra/services/website/#mavennucleoidxyz-and-buildnucleoidxyz","title":"maven.nucleoid.xyz and build.nucleoid.xyz","text":"<p>These are both also just \"static\" sites running under <code>apache2</code> (well all our web stuff goes through here, but most of them are just proxied).</p> <p>The maven repository is deployed to using sftp logging in as the <code>maven</code> user (ask on Discord for the password if you need to set something up to deploy there).</p> <p>The build site is just a symlink to the exports directory of the building server.</p> <p>Both are using h5ai for a nicer looking static file browser.</p>"},{"location":"admin/infra/services/website/#statsnucleoidxyz","title":"stats.nucleoid.xyz","text":"<p>Running under <code>docker-compose</code> from <code>/home/minecraft/services/stats</code>.</p>"},{"location":"admin/infra/services/website/#apinucleoidxyz","title":"api.nucleoid.xyz","text":"<p>Is reverse proxied through to several services:</p> <ul> <li>backend</li> <li>mitosis</li> <li>face-api</li> </ul>"},{"location":"backend/","title":"About","text":"<p>Nucleoid uses a backend service written in rust as a central point for storing and handling data. It is currently used for the following things:</p> <ul> <li>HTTP API used to query information about the server and players.</li> <li>Discord bot and relays to link ingame chat to Discord channels.</li> <li>Statistics storage in a ClickHouse database</li> <li>Recording performance metrics from the Minecraft servers into a postgresql database, for display on Grafana.</li> </ul>"},{"location":"backend/http-api/","title":"HTTP API","text":"<p>Nucleoid's backend service provides a few API endpoints for querying information about the server and players.</p> <p>The official backend API is available on https://api.nucleoid.xyz/</p>"},{"location":"backend/http-api/#general-information","title":"General information","text":""},{"location":"backend/http-api/#data-types","title":"Data types","text":"<p>All dates/times returned by the API are in RFC 3339 format unless specified otherwise.</p>"},{"location":"backend/http-api/#limits","title":"Limits","text":"<p>By default, the backend has a maximum query size of 50, however this can and may be changed in future. This applies to all routes that take a <code>limit</code> query parameter.</p> <p>There is currently also no rate-limiting on the API, however this may change in future if it causes issues.</p>"},{"location":"backend/http-api/#status","title":"Status","text":""},{"location":"backend/http-api/#server-status","title":"Server status","text":"<p>Example</p> <pre><code>GET https://api.nucleoid.xyz/status/play\n\n{\n    \"game_version\": \"1.16.4\",\n    \"server_ip\": \"nucleoid.xyz\",\n    \"games\": [\n        {\n            \"name\": \"Bedwars\",\n            \"type\": \"bedwars:bedwars\",\n            \"player_count\": 1\n        }\n    ],\n    \"players\": [\n        {\n            \"name\": \"Tom_The_Geek\",\n            \"id\": \"07e92b46-8386-4067-8f72-8ab96e606fb7\"\n        }\n    ]\n}\n</code></pre> <p>This endpoint allows you to query the status of any of the Nucleoid servers. Currently the following servers are available to query:</p> <ul> <li><code>play</code>: The main server on hosted on <code>nucleoid.xyz</code> and <code>play.nucleoid.xyz</code></li> <li><code>build</code>: The whitelisted server used for map building, hosted on <code>build.nucleoid.xyz</code></li> </ul> Field Description <code>game_version</code> The version of Minecraft the server is running <code>server_ip</code> The public IP of the server, optional <code>games</code> A list of all open minigames on the server <code>players</code> A list of all players on the server"},{"location":"backend/http-api/#statistics","title":"Statistics","text":""},{"location":"backend/http-api/#get-recent-games","title":"Get recent games","text":"<p>Example</p> <pre><code>GET https://api.nucleoid.xyz/games/recent?limit=10\n\n[\n    {\n        \"id\":\"f0087cb4-dee2-4b99-8158-d20cd72b343d\",\n        \"namespace\": \"bedwars\",\n        \"players\": [\n            \"5ad3ab57-b556-4635-9ba9-9a9a0568965a\"\n        ],\n        \"server\": \"play\",\n        \"date_played\": \"2021-10-30T16:24:47Z\"\n    }\n]\n</code></pre> <p>Queries a list of recently played games on the server. The limit argument is required and specifies the maximum number of games returned.</p>"},{"location":"backend/http-api/#recent-game-object","title":"Recent game object","text":"Field Description <code>id</code> The ID of the game, can be used to query with the Get stats for game endpoint <code>namespace</code> Usually the ID of the game that was played <code>players</code> A list of the player IDs of the players in the game <code>server</code> ID of the server the game was played on (see Server status) <code>date_played</code> Timestamp of when the game was played"},{"location":"backend/http-api/#get-recent-games-player","title":"Get recent games (player)","text":"<p>Example</p> <pre><code>GET https://api.nucleoid.xyz/games/recent?limit=10&amp;player=f0087cb4-dee2-4b99-8158-d20cd72b343d\n\n[\n    {\n        \"id\":\"f0087cb4-dee2-4b99-8158-d20cd72b343d\",\n        \"namespace\": \"bedwars\",\n        \"players\": [\n            \"5ad3ab57-b556-4635-9ba9-9a9a0568965a\"\n        ],\n        \"server\": \"play\",\n        \"date_played\": \"2021-10-30T16:24:47Z\"\n    }\n]\n</code></pre> <p>Queries a list of recently played games by a particular player on the server.</p> <p>The limit argument is required and specifies the maximum number of games returned.</p> <p>The returned object is the same format as Get recent games, and is documented at Recent game object</p>"},{"location":"backend/http-api/#get-all-player-stats","title":"Get all player stats","text":"<p>Example</p> <pre><code>GET https://api.nucleoid.xyz/stats/player/07e92b46-8386-4067-8f72-8ab96e606fb7\n\n{\n    \"bedwars\": {\n        \"damage_dealt\": 1238.8,\n        \"final_kills\": 56.0,\n        \"kills\": 84.0,\n        \"blocks_placed\": 532.0,\n        \"beds_destroyed\": 21.0\n    }\n}\n</code></pre> <p>Allows for querying all the statistics of a player.</p> <p>Note</p> <p>The response is relatively unstructured, as players may have different combinations of games they have collected statistics for.</p> <p>The best way to describe the response of this endpoint is by describing the data format on the backend. The data returned is described in rust as <pre><code>type PlayerStatisticsResponse = HashMap&lt;String, HashMap&lt;String, f64&gt;&gt;;\n</code></pre> Rust's <code>HashMap</code>s are similar to dictionaries in other languages or objects in JavaScript.</p>"},{"location":"backend/http-api/#get-player-stats-for-a-game","title":"Get player stats for a game","text":"<p>Example</p> <pre><code>GET https://api.nucleoid.xyz/stats/player/07e92b46-8386-4067-8f72-8ab96e606fb7/bedwars\n\n{\n    \"bedwars\": {\n        \"damage_dealt\": 1238.8,\n        \"final_kills\": 56.0,\n        \"kills\": 84.0,\n        \"blocks_placed\": 532.0,\n        \"beds_destroyed\": 21.0\n    }\n}\n</code></pre> <p>Allows for filtering the returned statistics by a particular game/namespace. It will return a response in the same format as Get all player stats, just without stats for minigames other than the specified one.</p>"},{"location":"backend/http-api/#get-stats-for-game","title":"Get stats for game","text":"<p>Example</p> <pre><code>GET https://api.nucleoid.xyz/stats/game/bda420f0-b480-4f8b-bcc5-7c6c63d51643\n\n{\n    \"07e92b46-8386-4067-8f72-8ab96e606fb7\": {\n        \"bedwars\": {\n            \"final_kills\": 8,\n            \"blocks_placed\": 76,\n            \"beds_destroyed\": 3,\n            \"kills\": 12,\n            \"damage_dealt\": 154.85\n        }\n    },\n    \"00000000-0000-0000-0000-000000000000\": {\n        \"bedwars\": {\n            \"teams\": 4\n        }\n    }\n}\n</code></pre> <p>Allows for querying the statistics after a particular game has been played.</p> <p>Note</p> <p>The <code>00000000-0000-0000-0000-000000000000</code> UUID represents global statistics from the game, such as the number of teams.</p> <p>Note</p> <p>Like the other statistics endpoints, this data is quite unstructured, and is best described with the following: <pre><code>type GameStatisticsResponse = HashMap&lt;uuid::Uuid, HashMap&lt;String, HashMap&lt;String, f64&gt;&gt;&gt;;\n</code></pre> The <code>uuid::Uuid</code> type can be substituted for <code>String</code> if your language doesn't have a specific type for <code>UUID</code>s.</p>"},{"location":"backend/http-api/#get-statistics-stats","title":"Get statistics stats","text":"<p>Example</p> <pre><code>GET https://api.nucleoid.xyz/stats/stats\n\n{\n    \"unique_players\": 141,\n    \"games_played\": 540,\n    \"entries\": {\n        \"player\": 10125,\n        \"global\": 0,\n        \"total\": 10125\n    },\n    \"grand_total\": {\n        \"player\": 662742.2732343078,\n        \"global\": 0,\n        \"total\": 662742.2732343078\n    }\n}\n</code></pre> <p>Returns some information about the amount of statistics that have been recorded in total.</p>"},{"location":"backend/http-api/#leaderboards","title":"Leaderboards","text":""},{"location":"backend/http-api/#get-leaderboard","title":"Get leaderboard","text":"<p>Example</p> <pre><code>GET https://api.nucleoid.xyz/leaderboard/nucleoid:games_played\n\n[\n    {\n        \"player\": \"0529de78-7795-4382-ba3c-350fe3159cc3\",\n        \"ranking\": 1,\n        \"value\": 151\n    },\n    {\n        \"player\": \"c705fc7d-0962-4d1e-905b-b83d81d9b4ec\",\n        \"ranking\": 2,\n        \"value\": 136\n    },\n    {\n        \"player\": \"c40d10d3-f2ee-47a6-92ec-63b53b6fdf01\",\n        \"ranking\": 3,\n        \"value\": 109\n    },\n    ...\n]\n</code></pre> <p>Returns the top 10 of the specified leaderboard.</p>"},{"location":"backend/http-api/#leaderboard-entry-object","title":"Leaderboard entry object","text":"Field Description <code>player</code> The UUID of the player <code>ranking</code> The player's position in the leaderboard <code>value</code> The score/statistic value the player has in this leaderboard <p>Warning</p> <p>This endpoint may be changed in future to allow querying a specific section of the leaderboard.</p>"},{"location":"backend/http-api/#get-player-rankings","title":"Get player rankings","text":"<p>Example</p> <pre><code>GET https://api.nucleoid.xyz/player/5ad3ab57b55646359ba99a9a0568965a/rankings\n\n{\n    \"nucleoid:games_played\": [34, 15],\n    \"destroy_the_monument:games_won\": [14, 1],\n    \"destroy_the_monument:total_kills\": [19, 8],\n    \"destroy_the_monument:damage_dealt\": [19, 237.21775656938553],\n    \"electricfloor:longest_time\": [27, 70.85],\n    \"electricfloor:blocks_converted\": [15, 536]\n}\n</code></pre> <p>Allows for querying a player's locations in the leaderboards. Each item in the returned item corresponds to one leaderboard, and the value is a pair, <code>[ranking, value]</code>, which have the same meaning as in the Leaderboard entry object</p>"},{"location":"build-rush/","title":"About","text":"<p>Build Rush is a build memorizing minigame for Minecraft! The goal is to memorize a structure and then rebuild it as fast and as correct as possible.</p> <p>Info</p> <p>This tutorial is currently updated for Build Rush 3.0.2.</p>"},{"location":"build-rush/builds/","title":"Adding a build","text":""},{"location":"build-rush/builds/#building-and-saving-the-structure","title":"Building and saving the structure","text":"<p>Warning</p> <p>You need to know how to use the structure block and its SAVE mode to create a build.</p> <p>First off, you need to build your structure in any creative world that you can download generated structures from. Either in a single-player world, or in a server that allows you to do so.</p> <p>Tip</p> <p>If you have access to the Nucleoid build server, you can join the original builds map <code>/map join buildrush:builds</code>. This map contains all the builds that were made by fellow Nucleoid contributors up to 3.0.0.</p> <p>To download any generated build on the Nucleoid build server, visit this site: https://build.nucleoid.xyz/</p> <p>You also need to choose a size for your build. Builds must have the same width, length and height. Let's say you want a size of <code>n</code> blocks for you build. This means you need to create a structure of dimensions <code>n</code>x<code>n</code>x<code>n</code>.</p> <p>You can also add a custom floor for your build, allowing the structure to be <code>n</code>x<code>n+1</code>x<code>n</code>. Players won't have to build this floor, as it will replace the floor of all plots when building. Please make sure that all blocks of the floor have a solid top surface.</p> <p>Tip</p> <p>Do not worry about falling blocks like sand for you floor, as barrier blocks will be placed under the plot floors if the map does not have blocks there.</p> <p>Example</p> <p>If you want to create a build of size 7, you can create a structure of dimensions 7x8x7, with the floor being at the bottom of the structure. If you do not want this floor, you can create a structure of dimensions 7x7x7.</p> <p>After finishing your build, save it using the structure block. The name of the structure file can be renamed manually afterward. Entities are not supported, so make sure to not include them while saving.</p> <p>Structures are stored under the <code>structures</code> folder of the datapack, so save it there when you're done.</p>"},{"location":"build-rush/builds/#creating-the-build-file","title":"Creating the build file","text":"<p>You now need to add a build configuration that will add information about your build. Builds are stored in the <code>build_rush/builds</code> folder of the datapack, so create a <code>.json</code> file there.</p> <p>Here are the configuration fields of a build: <pre><code>{\n  \"structure\": \"build_rush:build/my_build\",\n  \"name\": {\n    \"translate\": \"build.my_build\"\n  },\n  \"author\": {\n    \"name\": \"jeb_\",\n    \"uuid\": \"853c80ef-3c37-49fd-aa49-938b674adae6\"\n  }\n}\n</code></pre></p> Field Description Required Defaults to <code>structure</code> The path to the structure file. Yes <code>name</code> The name of the build. Yes <code>author</code> The author of the build. No <code>author.name</code> The name of the author. Yes <code>author.uuid</code> The UUID of the author. No <p>Tip</p> <p>If a game tries to load any build that is not valid in any way, it will get ignored and a warning will be sent in the console.</p> <p>A standalone build will not get used in any gamemode, that's because it is the game config that defines the list of builds that it's going to use. However, you can add your build to the <code>build_rush:generic</code> tag, which is used by the generic game modes.</p>"},{"location":"build-rush/builds/#notes-on-contributions","title":"Notes on contributions","text":"<p>If you are contributing to the Build Rush repository, please make sure to follow this checklist before submitting your pull request: - Your build is replicable in normal gameplay, on any maps. (no floating blocks) - Your build features as less redstone mechanics as possible. - If the name of your build is already used, add an underscore and a number at the end of the name. (<code>build</code>, <code>build_2</code>, <code>build_3</code>, ...) - Your structure file and your build configuration have the same name. - The structure is saved under the <code>structures/builds</code> folder inside the <code>build_rush</code> datapack. - If the build is not made for specific gamemode, add it to the <code>build_rush:generic</code> build tag. - The build name is translatable. Use existing translations if possible, if not add a translation key that follows the <code>build.&lt;name&gt;</code> pattern.</p> <p>Warning</p> <p>Currently, the generic game modes of Build Rush were made for build sizes of 5, 7 and 9. Only size 5 is used for now though. </p>"},{"location":"build-rush/maps/","title":"Adding a map","text":""},{"location":"build-rush/maps/#creating-the-map-template","title":"Creating the map template","text":"<p>Please follow the Plasmid tutorial on how to create a map template.</p> <p>A Build Rush map template needs the following regions: - <code>center_plot</code>: the center of the map, where the players will be teleported to at first, and where the chosen build may appear at points. (only 1) - <code>plot</code>: the plots where the players will build. There must be at least as many plots as the max amount of players in the game configuration (see below).</p> <p>A map can only support one size of builds. The size of the chosen builds is determined by the size of the plots.</p> <p>All plots must be of the same size (width and length) and be 1 block high.</p> <p>Tip</p> <p>If you get anything wrong with your map, the game will not start. You can check the logs to see what went wrong.</p> <p>Map templates are stored in the <code>map_templates</code> folder of the datapack, so save it there when you're done.</p>"},{"location":"build-rush/maps/#creating-the-game-configuration","title":"Creating the game configuration","text":"<p>Please follow the Plasmid tutorial on how to create a game configuration.</p> <p>You now need to add a game configuration that will use your map. Game configurations are stored in the <code>games</code> folder of the datapack, so create your <code>.json</code> file there.</p> <p>Here are the configuration fields added by Build Rush, on top of the ones added by Plasmid: <pre><code>{\n  // ...\n  \"players\": {\n    \"min\": 1,\n    \"threshold\": 8,\n    \"max\": 16\n  },\n  \"map\": {\n    \"template\": \"build_rush:my_map\",\n    \"nametag_offset\": 5,\n    \"nametag_size\": 2.0,\n    \"author\": {\n      \"name\": \"jeb_\",\n      \"uuid\": \"853c80ef-3c37-49fd-aa49-938b674adae6\"\n    }\n  },\n  \"builds\": \"#build_rush:generic\"\n  // ...\n}\n</code></pre></p> <p>The game type is <code>build_rush:standard</code>.</p> Field Description Required Defaults to <code>players</code> The configuration of number of players. Yes <code>map</code> The configuration of the map. Yes <code>map.template</code> The map template to use. Yes <code>map.nametag_offset</code> The offset of the name tag above the player's plot. No 10 <code>map.nametag_size</code> The size of the name tag above the player's plot. No 5.0 <code>map.author</code> The author of the map. No <code>map.author.name</code> The name of the author. Yes <code>map.author.uuid</code> The UUID of the author. No <code>builds</code> The list of builds to use. Can be a list of builds, or a tag. Yes #build_rush:generic <p>The <code>#build_rush:generic</code> tag includes most of the available builds.</p> <p>Note</p> <p>The builds field can contain any builds, even if they are not compatible with the map. Only compatible builds from the entry list will get used.</p>"},{"location":"build-rush/maps/#notes-on-contributions","title":"Notes on contributions","text":"<p>If you are contributing to the Build Rush repository, please make sure to follow this checklist before submitting your pull request: - Your map template and game configuration have the same name. - Your game configuration is in the correct subfolder: <code>small</code> is for maps compatible with 5x5 builds, <code>medium</code> is for 7x7, and <code>large</code> is for 9x9. - Your game configuration is listed in the <code>random</code> game configuration in the same subfolder. - The game configuration follows this example:   <pre><code>{\n  // ...\n  \"name\": {\n    \"translate\": \"game.build_rush.small.with_map\",   // change \"small\" with \"medium\" or \"large\" depending on the size of your plots\n      \"with\": [\n      {\n        \"translate\": \"map.build_rush.my_map\"         // change \"my_map\" with the identifier of your map (and translate it in lang/en_us.json)\n      }\n    ]\n  },\n  \"icon\": \"minecraft:diamond\",                       // as your game will show up in the list of games, you need an item to represent it\n  // ...\n}\n</code></pre> - Your game configuration has an icon. - The build list is large enough, to counter the feeling of repetitiveness. If you don't have enough builds, leave the builds empty for the game to use the <code>#build_rush:generic</code> tag.</p>"},{"location":"plasmid/","title":"About","text":"<p>Plasmid is a library and mod that forms the core of Nucleoid, providing a base to build minigames on top of.</p> <p>From the plasmid README</p> <p>Plasmid intends to do all the boring work relating to minigame implementation, to rather allow focus effort on just the game itself.</p> <p>Warning</p> <p>The Plasmid tutorials and documentation may not represent the latest versions of Plasmid and Minecraft! Please check each page to know whether you are using the same versions.</p> <p>Note</p> <p>The current documentation is imported from the old GitHub wiki, and was originally written by Gegy.</p>"},{"location":"plasmid/getting-started/","title":"Getting Started","text":""},{"location":"plasmid/getting-started/#adding-to-gradle","title":"Adding to Gradle","text":"<p>Assuming you already have a Fabric workspace set up, the first step to setting up Plasmid will be adding it to your gradle buildscript. You will need to add the maven repository as well as the plasmid dependency. The Plasmid version should be replaced with the latest version from our versions page.</p> <p>Info</p> <p>This tutorial is currently updated for Plasmid 0.6.x and Minecraft 1.21.8.</p> <pre><code>repositories {\n  maven { url = 'https://maven.nucleoid.xyz/releases/' }\n}\n\ndependencies {\n  // ...\n  modImplementation 'xyz.nucleoid:plasmid:0.6.6+1.21.8'\n}\n</code></pre>"},{"location":"plasmid/getting-started/#creating-a-game-type","title":"Creating a game type","text":"<p>A \"game type\" (<code>GameType</code>) is the entry-point to creating a game with Plasmid: they provide a unique identifier for your game, as well as all the information needed for it to be able to call your code when the game starts.</p> <p>Plasmid is designed to encourage data-driven games, and works with the concept of a \"game config\". A game config is essentially a specific variation of a game type! This may involve a different map to play on, or entirely different game mechanics. A game config is simply defined as a JSON file in a datapack that references your <code>GameType</code> and passes along any extra data that may be useful for configuring your game. While this may be a bit more work at first, it is very powerful in allowing games to be much easier to tweak or produce multiple variations of without duplicating code. More on configs later!</p> <p>To register a <code>GameType</code>, you will need to call <code>GameTypes.register()</code> in your <code>ModInitializer</code> class. A call to register a <code>GameType</code> may look something like: <pre><code>GameTypes.register(\n        Identifier.of(\"plasmid_example\", \"example\"),\n        ExampleGameConfig.CODEC,\n        ExampleGame::open\n);\n</code></pre></p> <p>Let's break down what is going on here:</p> <ul> <li> <p><code>Identifier.of(\"plasmid_example\", \"example\")</code></p> <ul> <li>declares the unique identifier for this game type that will be referenced by game config JSONs</li> </ul> </li> <li> <p><code>ExampleGameConfig.CODEC</code></p> <ul> <li>a codec that will be used to load the game configuration from a JSON file (more on this later!)</li> </ul> </li> <li> <p><code>ExampleGame::open</code></p> <ul> <li>a method reference to a function that will be used to start your game when a player requests it</li> </ul> </li> </ul> <p>This naturally will not compile yet: neither <code>ExampleGame</code> nor <code>ExampleGameConfig</code> exist! Let's get to that.</p>"},{"location":"plasmid/getting-started/#creating-our-config-in-code","title":"Creating our config in code","text":"<p>First we will create our <code>ExampleGameConfig</code> class, which will hold a <code>String</code> field that will be used as a message to send to the player when they join. Java's new Records are perfect for configs, but not required!</p> <pre><code>public record ExampleGameConfig(String greeting) {\n}\n</code></pre> <p>That's simple enough! But we're missing the <code>CODEC</code> field that we referenced earlier. What is that about?</p> <p>A codec is a very helpful tool implemented by Mojang's DataFixerUpper library that essentially allows for convenient serialization and deserialization of a Java object to a JSON file. A more detailed explanation of Codecs by Drullkus can be found here, but for simple purposes, all you need to know is the pattern for putting them together.</p> <p>Essentially, a Codec describes how an object is serialized and deserialized. Simply, they can be created from a list of fields and how those fields should be serialized. It goes like this: <pre><code>public record ExampleGameConfig(String greeting) {\n    public static final MapCodec&lt;ExampleGameConfig&gt; CODEC = RecordCodecBuilder.mapCodec(instance -&gt; {\n        return instance.group(\n                Codec.STRING.fieldOf(\"greeting\").forGetter(ExampleGameConfig::greeting)\n        ).apply(instance, ExampleGameConfig::new);\n    });\n}\n</code></pre></p> <p>This will correspond to a JSON file that looks something like: <pre><code>{\n  \"greeting\": \"Hello World!\"\n}\n</code></pre></p> <p>Most things here you can ignore: you only really need to worry about what's in the <code>instance.group(...)</code> call, and the generic on the Codec. To look at each relevant part more specifically:</p> <ul> <li> <p><code>MapCodec&lt;ExampleGameConfig&gt;</code></p> <ul> <li>The type of class that is being deserialized into is passed as a generic parameter to the <code>MapCodec</code>.</li> </ul> </li> <li> <p><code>Codec.STRING.fieldOf(...).forGetter(...)</code></p> <ul> <li> <p>This adds a field with a given name and type that will be read from the JSON.</p> </li> <li> <p>You will notice that <code>Codec.STRING</code> is itself a <code>Codec&lt;String&gt;</code>! Every field you declare will require a Codec to describe how that field should be handled. In this case, we're indicating that the greeting field should be loaded using <code>Codec.STRING</code>. In the same way, we could reference any other codec we create to add it as a field! This is very useful in allowing combinations of codecs to create complex structures!</p> <ul> <li>Codec tip: most serializable Minecraft types will hold a static <code>CODEC</code> field for use (e.g. <code>BlockPos.CODEC</code> or <code>Identifier.CODEC</code>). If not, we bundle a <code>MoreCodecs</code> type which provides some common ones that are not included in the vanilla codebase (e.g. <code>MoreCodecs.TEXT</code>).</li> </ul> </li> <li> <p>The parameter to <code>.fieldOf()</code> specifies the name of the field (in JSON) that this value will be read from.</p> </li> <li> <p><code>.forGetter()</code> specifies how the value of a field should be read back from our config object. This is useful since codecs allow for both serialization and deserialization, and the getter is required to turn the object back into data. We can use a method reference here since we're using a record.</p> </li> </ul> </li> <li> <p><code>ExampleGameConfig::new</code></p> <ul> <li> <p>This tells the codec how to create the object once all the fields have been deserialized. This requires a method reference to the constructor for the given object with all the fields in order as they were specified!.</p> </li> <li> <p>For example, if we passed <code>Codec.STRING.fieldOf(\"foo\")</code> and then <code>Codec.INT.fieldOf(\"bar)</code>, the constructor would take a <code>(String, int)</code>.</p> </li> <li> <p>But here we take in one <code>String</code> field, and the constructor we reference also takes a single <code>String</code> parameter.</p> </li> </ul> </li> </ul> <p>The end result of all this Codec work is that when we create a game config, all this data will be automatically parsed from our JSON file and passed to our game code!</p>"},{"location":"plasmid/getting-started/#creating-a-config","title":"Creating a config","text":"<p>Now that we know what data our config should hold, we can create an actual game config JSON for Plasmid to load.</p> <p>All game configs need to be located in your mod resources (or datapack!) at <code>data/&lt;namespace&gt;/plasmid/game/&lt;id&gt;.json</code>. For the purpose of a mod, the <code>namespace</code> should just be your mod id, and the <code>id</code> can be any unique name that will later be used to reference your game config from inside Minecraft.</p> <p>Plasmid requires only 1 JSON field from the config, while the rest is loaded as per the config codec that you set up. There are however also some additional optional fields which may be useful to define. The only required field is the <code>type</code>, which refers to the <code>GameType</code> you created earlier in <code>namespace:path</code> format (e.g. in our case, <code>plasmid_example:example</code>).</p> <p>For our purposes, our game config at <code>data/plasmid_example/plasmid/game/hello_world_example.json</code> will look like: <pre><code>{\n  \"type\": \"plasmid_example:example\",\n  \"greeting\": \"Hello, World!\"\n}\n</code></pre></p> <p>We can also add some additional builtin fields to our JSON such as a <code>name</code>, <code>short_name</code>, <code>description</code>, and <code>icon</code>. This may look like: <pre><code>{\n  \"type\": \"plasmid_example:example\",\n  \"greeting\": \"Hello, World!\",\n\n  \"name\": \"Hello World Example!\",\n  \"description\": [\"Look at my cool game!\", \"It greets you when you join.\"],\n  \"icon\": \"minecraft:apple\"\n\n  // ...\n}\n</code></pre></p> <p><code>name</code> and <code>description</code> can also reference translation keys due to being JSON Text Components. For example, this may instead be: <code>\"name\": {\"translate\": \"game.plasmid_example.hello_world_example\"}</code>.</p>"},{"location":"plasmid/getting-started/#a-note-on-translations","title":"A note on translations","text":"<p>Translations are a bit non-standard in Plasmid due to it being entirely server-side! Usually translations are stored with the game client, and the server simply sends over translation keys which are then turned into relevant readable text on the client-side. Here, however, we need to instead handle translations by changing the packets that get sent to players such that they are correctly translated before the client even receives it. This is a lot of work! Luckily, this is handled by Server Translations, and we do not need to worry about it!</p> <p>All this actually means for you is that your language files need to go in the <code>data</code> folder instead of the <code>assets</code> folder (e.g. <code>data/&lt;namespace&gt;/lang/en_us.json</code>).</p> <p>There are some default language keys we should worry about if we're not manually defining a name: <code>gameType.&lt;namespace&gt;.&lt;id&gt;</code> and <code>game.&lt;namespace&gt;.&lt;id&gt;</code>. These keys are applied for game types and game configs respectively. When resolving the readable name for a game config, both the config translation and type translation will be tested, with the type as a fallback. This means only the game type translation is strictly necessary.</p> <p>For example, we may define our <code>data/plasmid_example/lang/en_us.json</code> as: <pre><code>{\n  \"gameType.plasmid_example.example\": \"Plasmid Example!\",\n  \"game.plasmid_example.hello_world_example\": \"Hello World Example!\"\n}\n</code></pre></p>"},{"location":"plasmid/getting-started/#writing-the-code-to-start-our-game","title":"Writing the code to start our game","text":"<p>Now that we have set up a config and have told Plasmid how to read from it, we can finally write the code to actually start our game.</p> <p>For the purpose of this example, let's create an <code>ExampleGame</code> class. We will use this class to hold the state of the game as well as our <code>ExampleGameConfig</code> that got loaded. For now though, we just need to create this <code>open</code> function that we referenced to the <code>GameType</code>.</p> <p>This should look like: <pre><code>public class ExampleGame {\n    public static GameOpenProcedure open(GameOpenContext&lt;ExampleGameConfig&gt; context) {\n        // get our config that got loaded by Plasmid\n        ExampleGameConfig config = context.config();\n\n        // create a very simple map with a stone block at (0; 64; 0)\n        MapTemplate template = MapTemplate.createEmpty();\n        template.setBlockState(new BlockPos(0, 64, 0), Blocks.STONE.getDefaultState());\n\n        // create a chunk generator that will generate from this template that we just created\n        TemplateChunkGenerator generator = new TemplateChunkGenerator(context.server(), template);\n\n        // set up how the world that this minigame will take place in should be constructed\n        RuntimeWorldConfig worldConfig = new RuntimeWorldConfig()\n                .setGenerator(generator)\n                .setTimeOfDay(6000);\n\n        return context.openWithWorld(worldConfig, (activity, world) -&gt; {\n            // to be implemented\n        });\n    }\n}\n</code></pre></p> <p>There is a lot to unpack here, but it's not too complex if we break it down. Our <code>open</code> will be called whenever a player starts this game. The function takes a <code>GameOpenContext</code>, which holds the data from our JSON config (<code>context.config()</code>), and must return a <code>GameOpenProcedure</code>, which instructs Plasmid how it should continue to set up the game. It is worth nothing that this function is run asynchronously on the thread pool, so it is safe to run whatever slow code here before the game starts.</p> <p>The <code>GameOpenProcedure</code> is created from the <code>GameOpenContext.openWithWorld</code> function, and takes in a <code>RuntimeWorldConfig</code> as well as a lambda that accepts a <code>GameActivity</code> and <code>ServerWorld</code>. A runtime world is a concept within Plasmid that represents the fully isolated and temporary world that the game takes place within. It is automatically deleted when the game finishes. When a player joins the game, their inventory will be cleared, and when they leave, it will be restored back to them. A game activity is a specific set of logic that is running within a game: this is what we will configure to change game behaviour. We can switch the activity within a game at any point.</p> <p>The <code>RuntimeWorldConfig</code> describes how this world should be created. The most important thing to be configured within here is the chunk generator: this tells the game how the world should generate. It would be possible to, for example, pass the overworld chunk generator here, but for our purpose, we're creating an empty world with a single stone block. This is handled through the convenience <code>TemplateChunkGenerator</code>: this takes a <code>MapTemplate</code>, which is just a very basic world that contains some blocks! The generator then loads from that into the world itself.</p> <p>Finally, we need to address what to do in the lambda with the <code>GameActivity</code> parameter. The code inside this lambda will run on the main server thread, and is used to run the actual game setup code. This mainly involves registering event listeners, or setting global rules.</p> <p>Event tip: we make use of Stimuli for handling many events in games, so any event from there can be used within Plasmid.</p> <p>For example: <pre><code>return context.openWithWorld(worldConfig, (activity, world) -&gt; {\n    activity.deny(GameRuleType.FALL_DAMAGE);\n\n    activity.listen(GamePlayerEvents.ADD, player -&gt; {\n        // a player has been added!\n    });\n});\n</code></pre></p> <p>This code will disable fall damage for all players, as well as registering an event listener that will be called whenever a player is added to this game.</p> <p>However! Before we give functionality to our brilliant example game, we need to respond to the player offer and accept event listeners. These listeners are called before any player joins the game and are responsible for accepting or rejecting join requests as well as defining how and where the player should be spawned into our game world.</p> <p>Specifically, you can think of the process as the following:</p> <ul> <li>A player (or perhaps a group of players) tries to join a game</li> <li>The <code>GamePlayerEvents.OFFER</code> listener is called with a 'join offer', representing the players and their 'join intent' (particularly either participating or spectating)</li> <li>The offer is either accepted or rejected by the game through a <code>JoinOfferResult</code></li> <li>The <code>GamePlayerEvents.ACCEPT</code> listener is called</li> <li>The acceptor teleports the relevant players into the game space world</li> </ul> <p>This model has one primary benefit: allowing offers to be handled separately from the teleport logic means that games can reject players even if they are not actually on the server. Note that both of these listeners must be handled, or else players will be unable to join the game!</p> <p>An example offer and accept listener may look like: <pre><code>activity.listen(GamePlayerEvents.OFFER, JoinOffer::accept);\n\nactivity.listen(GamePlayerEvents.ACCEPT, acceptor -&gt; {\n    return acceptor.teleport(world, new Vec3d(0.5, 65.0, 0.5))\n            .thenRunForEach(player -&gt; {\n                player.changeGameMode(GameMode.ADVENTURE);\n            });\n});\n</code></pre></p> <p>That's a lot! Let's break it down:</p> <ul> <li> <p>We register a listener for <code>GamePlayerEvents.OFFER</code> with the <code>JoinOffer::accept</code> method reference. This indicates that join offers should always be accepted by the game.</p> </li> <li> <p>We register a listener for <code>GamePlayerEvents.ACCEPT</code> which takes an <code>acceptor</code> parameter.</p> </li> <li> <p>We call <code>acceptor.teleport(...)</code> to teleport the joining player(s) into the game.</p> <ul> <li>We pass the teleport function a world and a position for the player to be teleported to. The world was passed to us above by Plasmid!</li> </ul> </li> <li> <p>We then call <code>.thenRunForEach(...)</code> on the result of <code>.teleport(...)</code> in order to gain access to <code>ServerPlayerEntity</code> instances and attach some additional spawn logic to be run when the player(s) join. In this case, that is to set the player's game mode to adventure mode as they join.</p> </li> </ul> <p>Now that we have that set up, we can return to our player add listener: as of right now, we're not doing anything when it is called. We want it to send a greeting to the player when they join. Let's implement that: <pre><code>GameSpace gameSpace = activity.getGameSpace();\nactivity.listen(GamePlayerEvents.ADD, player -&gt; {\n    Text message = Text.literal(config.greeting());\n    gameSpace.getPlayers().sendMessage(message);\n});\n</code></pre></p> <p>So we've added logic to send a message within the listener, but what is a <code>GameSpace</code>? A <code>GameSpace</code> is a concept introduced by Plasmid which, as the name implies, represents the space within which a game is occurring. For all our purposes, that space is just this one dimension that the game is playing within. The <code>GameSpace</code> is useful for us in that it keeps track of all the players within it, as well as the <code>ServerWorld</code> that the game is taking place within. Here, we access the <code>GameSpace</code> through <code>GameActivity.getGameSpace()</code>.</p> <p>Working with players additionally goes through a different Plasmid API: a <code>PlayerSet</code>. A <code>PlayerSet</code> represents just a list of players, and it can be iterated over or queried, but additionally provides utilities for performing bulk operations over many players. For example, sending a message! Here, we use <code>PlayerSet.sendMessage()</code> to send our greeting to every player within the game.</p> <p>Tada! \ud83c\udf89 We have a working game! But before we test it, let's do some minor reorganization. With all these handlers and lambdas, our code inside <code>createOpenProcedure</code> is going to get quite lengthy very quickly! It would be nice if we can put all event listeners on our <code>ExampleGame</code> object instead.</p> <p>Turns out, that works just fine, and we are left with our final <code>ExampleGame</code> setup: <pre><code>public final class ExampleGame {\n    private final ExampleGameConfig config;\n    private final GameSpace gameSpace;\n    private final ServerWorld world;\n\n    public ExampleGame(ExampleGameConfig config, GameSpace gameSpace, ServerWorld world) {\n        this.config = config;\n        this.gameSpace = gameSpace;\n        this.world = world;\n    }\n\n    public static GameOpenProcedure open(GameOpenContext&lt;ExampleGameConfig&gt; context) {\n        // get our config that got loaded by Plasmid\n        ExampleGameConfig config = context.config();\n\n        // create a very simple map with a stone block at (0; 64; 0)\n        MapTemplate template = MapTemplate.createEmpty();\n        template.setBlockState(new BlockPos(0, 64, 0), Blocks.STONE.getDefaultState());\n\n        // create a chunk generator that will generate from this template that we just created\n        TemplateChunkGenerator generator = new TemplateChunkGenerator(context.server(), template);\n\n        // set up how the world that this minigame will take place in should be constructed\n        RuntimeWorldConfig worldConfig = new RuntimeWorldConfig()\n                .setGenerator(generator)\n                .setTimeOfDay(6000);\n\n        return context.openWithWorld(worldConfig, (activity, world) -&gt; {\n            ExampleGame game = new ExampleGame(config, activity.getGameSpace(), world);\n\n            activity.deny(GameRuleType.FALL_DAMAGE);\n            activity.listen(GamePlayerEvents.OFFER, JoinOffer::accept);\n            activity.listen(GamePlayerEvents.ACCEPT, game::onAcceptPlayers);\n            activity.listen(GamePlayerEvents.ADD, game::onPlayerAdd);\n        });\n    }\n\n    private JoinAcceptorResult onAcceptPlayers(JoinAcceptor acceptor) {\n        return acceptor.teleport(this.world, new Vec3d(0.5, 65.0, 0.5))\n                .thenRunForEach(player -&gt; {\n                    player.changeGameMode(GameMode.ADVENTURE);\n                });\n    }\n\n    private void onPlayerAdd(ServerPlayerEntity player) {\n        Text message = Text.literal(this.config.greeting());\n        this.gameSpace.getPlayers().sendMessage(message);\n    }\n}\n</code></pre></p>"},{"location":"plasmid/getting-started/#testing-the-game","title":"Testing the game!","text":"<p>Once everything compiles, we can finally launch up Minecraft. If our <code>GameType</code> is all correctly set up and game config JSON in place, once opening a world, we should be able to start our game by running: <code>/game open &lt;id&gt;</code>. (Remember, this is referencing the name of the JSON file and not the GameType!)</p> <p>So in our case: <code>/game open plasmid_example:hello_world_example</code> ...and we should be joined into our void world with a stone block with a lovely greeting!</p> <p>Now, any other player can join us too by running <code>/game join</code> or clicking the link that shows up in chat.</p> <p>That's it! \ud83c\udf89 </p>"},{"location":"plasmid/maps/","title":"Creating a Map","text":"<p>Info</p> <p>This tutorial is currently updated for Plasmid 0.4.x and Minecraft 1.16.5.</p> <p>Any minigame needs a map for the game to take place within. This may be generated by your code- but most often, you just want to use a map that you built by hand. Plasmid introduces various tools which can be used in order to accomplish this. This page will address specifically the process of building the map and attaching various metadata that may be needed for the game to function through Map Workspaces.</p> <p>NOTE: The map tools have been moved to a separate mod called \"Nucleoid Creator Tools\", you can install those tools here.</p>"},{"location":"plasmid/maps/#opening-a-workspace","title":"Opening a workspace","text":"<p>The first step to creating a map is opening a map workspace. A map workspace is essentially just a dimension that you can build within, which can later be exported into a map template file readable by Plasmid.</p> <p>An empty void map workspace can be opened by running: <code>/map open &lt;id&gt;</code> (e.g. <code>/map open bedwars:cubes</code>) The required <code>id</code> is a unique identifier for your workspace in <code>namespace:identifier</code> format. It should be all lowercase and cannot have spaces.</p> <p>You are also able to create workspaces with custom chunk generators: <code>/map open &lt;id&gt; like &lt;dimension&gt;</code> (e.g. <code>/map open bedwars:nether like minecraft:nether</code>)</p>"},{"location":"plasmid/maps/#moving-in-and-out-of-workspaces","title":"Moving in and out of workspaces","text":"<p>Once you have created a workspace, you need to be able travel between them.</p> <p>This is possible by running: <code>/map join &lt;id&gt;</code>, which will teleport you into that workspace dimension. Once you are in the workspace dimension, you are free to build whatever you want!</p> <p>Likewise, it is possible to leave a map workspace and return to your former location by running: <code>/map leave</code>.</p>"},{"location":"plasmid/maps/#setting-the-map-bounds","title":"Setting the map bounds","text":"<p>When exporting a map to be loaded into a game, Plasmid needs to know the area of the world which should be included. This is controlled by setting a box that encompasses your map.</p> <p>When you first enter a workspace, you will notice a box outline formed by particles- these are your map bounds! They can be changed in a workspace by running: <code>/map bounds &lt;id&gt; &lt;corner_1&gt; &lt;corner_2&gt;</code>.   - <code>id</code> is the workspace id to set bounds for   - <code>corner_1</code> and <code>corner_2</code> are the two corners of the axis-aligned bounding box</p>"},{"location":"plasmid/maps/#setting-the-map-origin","title":"Setting the map origin","text":"<p>More often than not, you will not need to change the origin of a map workspace. Essentially, though, the map origin controls the block position that will correspond to (0; 0; 0) once the map is exported. This is useful if you built your map in the wrong place, and want to move it when the game actually starts.</p> <p>For example, if your map is 10 blocks too high, setting your origin to <code>(0; 10; 0)</code> will result in the exported map moving 10 blocks downward.</p> <p>This can be set through <code>/map origin &lt;id&gt; &lt;origin&gt;</code>   - <code>id</code> is the workspace id to set the origin for   - <code>origin</code> is the block position to set the origin to</p> <p>Be careful when setting origin to not cause your map to go out of bounds! If you set your map origin somewhere below the lower y of your map bounds, that will mean in the exported map, your bounds will be going below y=0!</p>"},{"location":"plasmid/maps/#working-with-regions","title":"Working with regions","text":"<p>Having a map that we can load for a minigame is useful, but the game logic is missing any sort of useful information about the map. For example, how can your minigame know where to spawn players, or where the bed for a specific team in bedwars is located?</p> <p>This is where regions come in: a region is just a named area of the map which can be used to communicate to the game code an area in which something should happen. There can be multiple regions in the map with the same name, or multiple regions with different names in the same location. The naming of regions is useful in order to identify to the game code what each region represents.</p>"},{"location":"plasmid/maps/#creating-a-region","title":"Creating a region","text":"<p>To get started with creating a region, run: <code>/give @s plasmid:add_region</code>. This gives you the Add Region item, which can be used to easily define regions within your world by selecting two corners.</p> <p>By right clicking on a block, a particle box should appear. This starts the process of defining a region by selecting the first corner. Now, as you look around, the box will shape to match the second corner. Right clicking a second time will select the current looked-at block as the second corner.</p> <p>Now, you can run <code>/map region commit &lt;marker&gt;</code>. This will add the highlighted region to your map with the given <code>marker</code>, and it should highlight with differently colored particles.</p> <p>When selecting a region with the Add Region item, you can additionally change the selection mode by sneaking &amp; right clicking. This cycles through 3 modes:   - offset mode: the highlighted block is the block you are looking at, offset by the side you are looking at it from (like placing a block)   - exact mode: the highlighted block is the exact block your are looking at (like breaking a block)   - at feet mode: the highlighted block is the block at your feet</p>"},{"location":"plasmid/maps/#useful-region-commands","title":"Useful region commands","text":"<ul> <li><code>/map region rename all &lt;old&gt; &lt;new&gt;</code>: renames all regions in the current workspace from <code>old</code> to <code>new</code></li> <li><code>/map region rename here &lt;old&gt; &lt;new&gt;</code>: renames all regions intersecting with your player in the current workspace from <code>old</code> to <code>new</code></li> <li><code>/map region remove here</code>:  removes all regions intersecting with your player from the current workspace</li> <li><code>/map region remove at &lt;pos&gt;</code>: removes all regions intersecting with the given <code>pos</code> from the current workspace</li> </ul>"},{"location":"plasmid/maps/#attaching-data","title":"Attaching data","text":"<p>It may desirable to communicate more information about the map to the code than just regions. This can be done by attaching arbitrary NBT data which is later accessible by the code.</p> <p>Data can be either attached to a region or to the map as a whole.</p> <p>To work with data on a specific region, your player must be intersecting that region's bounds!   - <code>/map region data &lt;marker&gt; get</code>: prints the data for the given region   - <code>/map region data &lt;marker&gt; set &lt;data&gt;</code>: sets the data for the given region (this will overwrite any previously existing data!)   - <code>/map region data &lt;marker&gt; merge &lt;data&gt;</code>: merges the given data with the existing data on the given region</p> <p>It is additionally possible to pass data to the region commit command: <code>/map region commit &lt;marker&gt; &lt;data&gt;</code></p> <p>To work with data on the global map, the commands function similarly:   - <code>/map data get</code>: prints the data attached to the map   - <code>/map data set &lt;data&gt;</code>: overwrites the existing data on the map   - <code>/map data merge &lt;data&gt;</code>: merges the given data with the existing data on the map</p>"},{"location":"plasmid/maps/#exporting-maps","title":"Exporting maps","text":"<p>Once your map is complete, you will want to export it into a file that can be loaded by Plasmid. This can be done simply by running: <code>/map export &lt;id&gt;</code>.</p> <p>The exported map will be placed in <code>/plasmid/exports/&lt;namespace&gt;/map_templates/&lt;path&gt;.nbt</code></p>"},{"location":"plasmid/statistics/","title":"Implementing statistics","text":"<p>Info</p> <p>This tutorial is currently updated for Plasmid 0.5.x and Minecraft 1.17.1.</p> <p>Plasmid provides an API for allowing minigames to record statistics for their players, and can be implemented to allow leaderboards to be generated for games (soon\u2122).</p>"},{"location":"plasmid/statistics/#before-you-begin","title":"Before you begin","text":"<p>This guide assumes that you have a minigame already implemented and want to add support for tracking statistics. If you simply would like to create a minigame, see the Getting Started guide.</p>"},{"location":"plasmid/statistics/#bundles-of-fun","title":"Bundles of fun","text":"<p>(Well it might not seem fun, but its the first step for implementing statistics into your game.)</p> <p>The first step for implementing statistics is getting your hands on a <code>GameStatisticBundle</code>, which is a class provided by plasmid that holds per-player and global statistics for your current game. You can do this quite easily within the constructor of your <code>GameActive</code> class like this: <pre><code>public class MyGameActive {\n    /* other fields */\n    public final GameStatisticBundle statistics;\n\n    private MyGameActive(GameSpace gameSpace, /* other parameters */) {\n        /* other initialization logic */\n\n        // The value passed to getStatistics should usually be the ID of your minigame/mod\n        this.statistics = gameSpace.getStatistics().bundle(MyGame.ID);\n    }\n\n    /* other game logic */\n}\n</code></pre></p> <p>You also need to provide a translation for the name of your bundle, with the translation key in the form <code>statistic.bundle.&lt;namespace&gt;</code>. This <code>namespace</code> is whatever you passed into <code>gameSpace.getStatistics().bundle()</code>, so double check it matches.</p>"},{"location":"plasmid/statistics/#getting-some-keys","title":"Getting some keys","text":"<p>Time to get implementi- Oh, we still need to do something else first :/</p> <p>Once you have a <code>GameStatisticsBundle</code>, the next step is to actually increment some statistics, and this is where the specifics can become different between games, as every game is somewhat unique.</p> <p>What are StatisticKeys?</p> <p><code>StatisticKey</code>s are a type-safe identifier for a specific statistic, and internally store both an <code>Identifier</code>.</p>"},{"location":"plasmid/statistics/#standard-keys","title":"Standard keys","text":"<p>Plasmid provides several built in <code>StatisticKey</code>s in a conveniently named <code>StatisticKeys</code> class. Here are some examples:</p> <ul> <li><code>GAMES_PLAYED</code></li> <li><code>KILLS</code></li> <li><code>DAMAGE_DEALT</code></li> <li><code>QUICKEST_TIME</code></li> </ul>"},{"location":"plasmid/statistics/#custom-keys","title":"Custom keys","text":"<p>You can create your own <code>StatisticKey</code>s and store them in <code>public static final</code> fields in a dedicated class, usually named something like <code>MyGameStatistics</code>. <pre><code>public class MyGameStatistics {\n    public static final StatisticKey&lt;Integer&gt; SOME_COOL_STAT =\n        // or StatisticKey.doubleKey or StatisticKey.floatKey\n        StatisticKey.intKey(new Identifier(MyGame.ID, \"some_cool_stat\"));\n}\n</code></pre></p> <p>If you implement custom keys, you need to ensure you provide translations for their names, in the form <code>statistic.&lt;id namespace&gt;.&lt;id path&gt;</code>, where <code>id namespace</code> and <code>id path</code> are the namespace and path of the <code>Identifier</code> you passed as the first argument when creating the key.</p> <p>Tip</p> <p>If you think other minigames could use a custom <code>StatisticKey</code> you implement, mention it in <code>#tools-and-libraries</code> on Discord and it might get included in plasmid's <code>StatisticKeys</code> class.</p>"},{"location":"plasmid/statistics/#incrementing-statistics","title":"Incrementing statistics","text":"<p>Now for the actually interesting part.</p> <p>Global and per-player statistics</p> <p>Per-player statistics are fairly self-explanatory; they're things like <code>KILLS</code> or <code>QUICKEST_TIME</code> that apply to a single player. Global statistics are a little different, as their values are not associated with a particular player, but with the entire game session. Global statistics can be used to store things like the number of teams in the game or the length of a course.</p> <p>Incrementing the statistics uses a fluent API style like the following: <pre><code>// For a player\nthis.statistics.forPlayer(player).increment(StatisticKeys.DEATHS, 1);\n// Or a global statistic\nthis.statistics.global().set(MyGameStatistics.TEAM_COUNT, 5);\n</code></pre> <code>player</code> can be either a <code>UUID</code>, <code>PlayerRef</code> or <code>ServerPlayerEntity</code>.</p> <p>The final step is to scatter these increments around your minigame and collect statistics for whatever seems interesting for players.</p>"},{"location":"plasmid/statistics/#finished","title":"Finished!","text":"<p>And then that's it, your minigame now has statistics support \ud83c\udf89!</p> <p>If you need a hand implementing or don't understand something, feel free to join the Discord and ask in <code>#minigame-dev</code>.</p>"},{"location":"plasmid/statistics/#extra-debugging","title":"Extra: debugging","text":"<p>If you want to double-check that your statistics are being counted correctly, you can add <code>-Dplasmid.debug_statistics=true</code> to your JVM arguments and plasmid will print out a JSON formatted version of all <code>GameStatisticBundle</code>s at the end of any game.</p>"}]}